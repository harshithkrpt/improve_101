DNS looks mundane on the surfaceâ€”â€œnames to numbersâ€â€”but under the hood itâ€™s a beautifully layered piece of network plumbing. Letâ€™s peel it from first principles and see how it really behaves.

---

## 1. What DNS is (from first principles)

Computers route packets using **IP addresses**. Humans, inconveniently, think in **names**. DNS (Domain Name System) is the globally distributed, hierarchical database that translates **human-readable names** like `api.example.com` into **machine-routable IP addresses** like `93.184.216.34`.

Two important subtleties often missed:

â€¢ DNS is **not a single server**. Itâ€™s a **federated system** of millions of servers cooperating under shared rules.
â€¢ DNS is **eventually consistent**, not instant truth. Caching is a feature, not a bug.

Think of DNS as the Internetâ€™s phone book, but one where:

* Everyone keeps partial copies
* Entries expire (TTL)
* Authority is delegated top-down

---

## 2. Which layer DNS lives in

DNS lives at the **Application Layer**.

Why?
Because DNS deals in *meaningful data structures* (domain names, record types, TTLs), not raw packet delivery. Everything below it just moves bytes.

Typical stack:

```
DNS (Application)
UDP / TCP (Transport)
IP (Network)
Ethernet / Wi-Fi (Link)
```

Transport details matter:

* **UDP port 53** â†’ default, fast, stateless
* **TCP port 53** â†’ zone transfers, large responses, DNSSEC, truncation fallback
* **DoH (DNS over HTTPS)** â†’ DNS inside HTTPS (port 443)
* **DoT (DNS over TLS)** â†’ DNS inside TLS (port 853)

The protocol is the same; only the *envelope* changes.

---

## 3. How DNS is routed (resolution flow)

DNS routing is not packet routingâ€”itâ€™s **question routing** via delegation.

When your app asks:

> â€œWhat is the IP for `www.google.com`?â€

Your machine doesnâ€™t magically know. It asks, step by step, *who might know*.

![Image](https://www.researchgate.net/publication/342003872/figure/fig2/AS%3A900085244248066%401591608453435/Domain-name-resolution-process-with-DNS.ppm)

![Image](https://gaia.cs.umass.edu/kurose_ross/interactive/dns_query.png)

![Image](https://blog.theodo.com/_astro/dns-hierarchy.CNS-fnn7_2pDSH3.webp)

### The resolution chain (simplified)

1. **Stub Resolver**
   Your OS sends a query to a **recursive resolver** (ISP, router, or public DNS).

2. **Recursive Resolver**
   If cached â†’ answer immediately.
   If not cached â†’ starts walking the hierarchy.

3. **Root Server**
   â€œI donâ€™t know `google.com`, but ask the `.com` servers.â€

4. **TLD Server (.com)**
   â€œI donâ€™t know `www.google.com`, but ask Googleâ€™s authoritative servers.â€

5. **Authoritative Server**
   â€œHere is the A/AAAA record. This is the truth.â€

6. **Caching on the way back**
   Resolver stores it for TTL seconds.

Key insight:
DNS **never routes data packets**, only **knowledge about where packets should go**.

---

## 4. How DNS looks on the wire (state, header, data)

DNS is deceptively compact. A full query often fits inside a single UDP packet.

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20220514144130/dnsquerymessage.png)

![Image](https://www.firewall.cx/images/stories/dns-response-format-9.gif)

![Image](https://www.tcpipguide.com/free/diagrams/dnsrrformat.png)

### DNS message structure

```
+---------------------+
| Header (12 bytes)   |
+---------------------+
| Question Section    |
+---------------------+
| Answer Section      |
+---------------------+
| Authority Section   |
+---------------------+
| Additional Section  |
+---------------------+
```

### Header (the brain stem)

Key fields:

* **Transaction ID** â€“ matches response to request
* **Flags**

  * QR (query/response)
  * RD (recursion desired)
  * RA (recursion available)
  * TC (truncated)
* **Counts**

  * QDCOUNT â€“ questions
  * ANCOUNT â€“ answers
  * NSCOUNT â€“ authority records
  * ARCOUNT â€“ additional records

Stateless doesnâ€™t mean brainless:
The transaction ID is how DNS pretends to be stateful over UDP.

---

### Question section

Example:

```
QNAME: www.google.com
QTYPE: A
QCLASS: IN
```

This is literally the question:
â€œGive me the IPv4 address for this name.â€

---

### Resource Records (Answer / Authority / Additional)

Each record looks like:

```
NAME | TYPE | CLASS | TTL | RDLENGTH | RDATA
```

Examples:

* **A** â†’ IPv4 address
* **AAAA** â†’ IPv6 address
* **CNAME** â†’ alias
* **NS** â†’ authoritative name server
* **MX** â†’ mail server

TTL is the quiet hero hereâ€”it defines how long lies are acceptable.

---

## A mental model worth keeping

DNS is:

* **Hierarchical** â†’ authority flows downward
* **Distributed** â†’ no central control
* **Cache-heavy** â†’ performance over purity
* **Mostly stateless** â†’ UDP-first design
* **Foundational** â†’ almost every network interaction starts with it

If TCP is the conversation and IP is the road system, DNS is the act of *looking up the address before you leave the house*. No lookup, no journey.

From here, the really interesting rabbit holes are DNS caching pathologies, DNSSEC trust chains, and how CDNs weaponize DNS responses to steer traffic globally. The map gets stranger the deeper you goâ€”and thatâ€™s where the fun starts.

`nslookup` and `dig` are two different lenses on the same beast: DNS. One is an old Swiss-army knife that talks back; the other is a scalpel that shows you the wire-level truth. Letâ€™s use both, hands-on, and decode what youâ€™re actually seeing.

---

## nslookup â€” conversational, quick checks

Think of `nslookup` as *interactive DNS probing*. Itâ€™s handy for fast sanity checks and basic debugging.

### Basic lookup

```
nslookup google.com
```

Typical output (annotated mentally):

* **Server** â†’ which DNS resolver answered you (ISP, router, 8.8.8.8, etc.)
* **Address** â†’ IP of that resolver
* **Non-authoritative answer** â†’ came from cache, not the source of truth
* **Name / Address** â†’ resolved IPs

Non-authoritative is not an error. Itâ€™s DNS doing its caching job.

---

### Query a specific DNS server

```
nslookup google.com 8.8.8.8
```

This bypasses your system resolver and asks Googleâ€™s DNS directly. Useful when:

* Your ISP DNS is lying
* You want to compare answers across resolvers

---

### Ask for a specific record type

```
nslookup -type=MX gmail.com
```

Youâ€™re asking:

> â€œWhere should email for this domain go?â€

Try also:

```
nslookup -type=NS google.com
nslookup -type=TXT google.com
```

TXT records often hide SPF, DKIM, domain verification, and other internet secrets.

---

### Interactive mode

```
nslookup
> server 1.1.1.1
> set type=A
> openai.com
> exit
```

This is useful when you want to experiment without retyping commands.

---

## dig â€” truth serum for DNS

`dig` (Domain Information Groper) is what network engineers use when they want **no abstraction, no fluff**.

### Basic query

```
dig google.com
```

Ignore the wall of text at first. Focus on:

* **QUESTION SECTION** â†’ what you asked
* **ANSWER SECTION** â†’ what you got
* **Query time** â†’ latency
* **SERVER** â†’ who answered

Everything else is context.

---

### Short answer only

```
dig google.com +short
```

Perfect for scripts and quick checks:

```
142.250.195.78
```

---

### Ask for a specific record

```
dig google.com A
dig google.com AAAA
dig google.com MX
```

Each maps directly to DNS record types. No magic.

---

### Trace the DNS resolution path (gold-tier command)

```
dig google.com +trace
```

This shows **the entire delegation chain**:

* Root servers
* `.com` TLD servers
* Googleâ€™s authoritative servers

This is DNS thinking out loud. If something breaks, `+trace` usually tells you *where*.

---

### Query a specific DNS server

```
dig @8.8.8.8 google.com
```

The `@` means:

> â€œAsk this server directly, donâ€™t involve my resolver.â€

Great for debugging split-horizon DNS, VPN issues, or CDN behavior.

---

### See TTL and authoritative answers

```
dig google.com +noall +answer
```

Example:

```
google.com.  300  IN  A  142.250.195.78
```

That `300` is the TTL in seconds.
This number explains **why DNS changes feel slow**.

---

### Compare UDP vs TCP

```
dig google.com +tcp
```

DNS normally uses UDP. TCP appears when:

* Response is large
* DNSSEC is involved
* Truncation happens

If UDP fails and TCP works, youâ€™ve learned something important.

---

## nslookup vs dig â€” when to use which

Use `nslookup` when:

* You want quick answers
* Youâ€™re on a minimal system
* You prefer interactive exploration

Use `dig` when:

* You want protocol-level clarity
* Youâ€™re debugging real DNS issues
* You care about TTLs, flags, authority, recursion

Professionally speaking:
`nslookup` asks *politely*.
`dig` interrogates.

---

## A useful mental habit

Whenever DNS feels â€œrandom,â€ run:

```
dig domain.com +trace
```

DNS almost never breaks randomly. It breaks **hierarchically**. This command shows you exactly where the chain snaps.

From here, the next natural curiosities are:

* Why CDNs return different IPs per location
* How DNS caching causes â€œit works on my machineâ€
* How DNSSEC adds cryptographic trust to this whole house of cards

DNS looks simple because it hides its complexity well. Tools like `dig` remind you that elegance is usually hard-won.

TLS certificates look mystical until you peel them back and realize theyâ€™re just very carefully signed blobs of math riding on top of TCP. Letâ€™s take this from a networking point of viewâ€”how a website *gets* a certificate, how itâ€™s *used on the wire*, and whatâ€™s *inside the thing*.

---



Letâ€™s unpack that slide from first principles and turn the buzzwords into moving parts. Think of this as â€œhow the web learned to whisper securely instead of shouting in public.â€

![Image](https://www.mariogerard.com/wp-content/uploads/2018/01/TPM-HTTP-vs-HTTPS.png)

![Image](https://cf-assets.www.cloudflare.com/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png)

![Image](https://upload.wikimedia.org/wikipedia/commons/c/c8/DiffieHellman.png)

![Image](https://www.practicalnetworking.net/wp-content/uploads/2015/11/dh-revised.png)

### Vanilla HTTP

Plain HTTP is a postcard.
Anyone handling it along the routeâ€”Wi-Fi router, ISP, corporate proxyâ€”can read it, copy it, or quietly modify it. No secrecy, no identity check, no integrity. Itâ€™s fast, simple, and wildly unsafe for anything sensitive.

### HTTPS (HTTP over TLS)

HTTPS is HTTP wrapped inside a secure tunnel called TLS (Transport Layer Security).
That tunnel gives you three big guarantees:

* **Confidentiality**: outsiders see encrypted noise.
* **Integrity**: tampering is detectable.
* **Authentication**: youâ€™re (probably) talking to the real server, not an impostor.

HTTP itself doesnâ€™t change. The wrapping does.

### TLS 1.2 Handshake (two round trips)

Before any real HTTP data flows, client and server perform a ritual handshake:

1. They agree on cryptographic algorithms.
2. The server proves its identity using a certificate.
3. They agree on shared secret keys.

In TLS 1.2 this costs **two full network round trips** before application data can move. On a high-latency network, that delay is painfully noticeable.

### Diffieâ€“Hellman (the clever math trick)

This is the magic that lets two parties agree on a shared secret **without ever sending the secret itself**.

Each side:

* Picks a private number.
* Exchanges only derived public values.
* Computes the same shared secret locally.

An eavesdropper sees the public values and learnsâ€¦ nothing useful.
Modern TLS uses **ephemeral Diffieâ€“Hellman** (DHE/ECDHE), which also gives *forward secrecy*: even if the serverâ€™s private key leaks later, past sessions remain safe. Cryptography with a memory wipe habit.

### TLS 1.3 Improvements (one round trip, sometimes zero)

TLS 1.3 cleaned house:

* Removed weak and legacy crypto.
* Encrypted more of the handshake itself.
* Reduced latency.

Result:

* **1-RTT handshake** for new connections.
* **0-RTT** for resumed sessions (client can send data immediately).

Zero round trip sounds like time travel, but itâ€™s really cached trust plus careful cryptographic constraints. Slight replay risks exist, which is why 0-RTT is optional and limited.

### The big picture

HTTP talks.
TLS negotiates trust, secrecy, and keys first.
TLS 1.2 made security mainstream but chatty.
TLS 1.3 made it lean, fast, and harder to misuse.

Underneath all of this, itâ€™s still packets, math, and patience battling latency and attackers. The web didnâ€™t become secure by accidentâ€”it became secure by layers of paranoia refined over decades.

---

## 1. Why TLS certificates exist (network-first view)

When your browser connects to `https://example.com`, three problems must be solved **before** HTTP can safely flow:

1. **Identity** â€“ â€œAm I really talking to example.com?â€
2. **Key exchange** â€“ â€œHow do we agree on a secret key over the open internet?â€
3. **Integrity** â€“ â€œHow do I know nobody modified packets in transit?â€

TLS certificates solve **identity**, and *enable* the other two.

---

## 2. How websites generate a TLS certificate

From the serverâ€™s perspective, the flow is surprisingly mechanical.

### Step A: Generate a key pair (offline, local)

The website owner generates:

* a **private key** (kept secret on the server)
* a **public key** (safe to share)

This is pure cryptographyâ€”no networking yet.

### Step B: Create a CSR (Certificate Signing Request)

A CSR is basically:

> â€œHere is my public key, and here is the identity I claim.â€

It includes:

* Domain name (`example.com`)
* Organization info (optional)
* Public key

### Step C: Send CSR to a Certificate Authority (CA)

The CSR goes to a CA (like Letâ€™s Encrypt, DigiCert, etc.).

The CA performs **validation**:

* **DV** (Domain Validation): Can you control DNS or respond on port 80/443?
* **OV/EV**: Extra legal checks (less common today)

If validation passesâ€¦

### Step D: CA signs it â†’ Certificate issued

The CA:

* hashes the certificate data
* encrypts that hash using the CAâ€™s **private key**
* attaches the signature

Now the certificate is **globally verifiable**.

---

## 3. What happens on the network during a TLS handshake

This is where packets start doing serious work.

![Image](https://cf-assets.www.cloudflare.com/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png)

![Image](https://www.thesslstore.com/blog/wp-content/uploads/2017/01/SSL_Handshake_10-Steps-1.png)

![Image](https://www.researchgate.net/publication/306187575/figure/fig1/AS%3A395752913293314%401471366255623/HTTPS-message-sequence-diagram-with-detailed-TLS-handshaking-steps.png)

### High-level packet flow (TLS 1.2/1.3 simplified)

1. **ClientHello**

   * Supported TLS versions
   * Cipher suites
   * Random number

2. **ServerHello**

   * Chosen cipher suite
   * Server random
   * **Certificate (sent here!)**

3. **Certificate verification (client-side)**

   * Browser checks:

     * Signature
     * Domain name
     * Expiry
     * Trust chain

4. **Key exchange**

   * Uses the *public key from the certificate*
   * Derives a symmetric session key

5. **Finished**

   * From now on: encrypted HTTP (HTTPS)

Important networking insight:

> **Certificates are sent in plaintext** during handshake.
> They donâ€™t need secrecyâ€”only authenticity.

---

## 4. Dissecting a TLS certificate (whatâ€™s inside)

Letâ€™s slice the certificate open conceptually.

![Image](https://learn.microsoft.com/en-us/windows/win32/seccertenroll/images/x509certificateversions.png)

![Image](https://cf-assets.www.cloudflare.com/zkvhlag99gkb/29TLfMfCAPTDpQygz5ZK0v/3f6c549538c598bbc5046f93b0492fdd/certificate_optimization_logic.png)

![Image](https://www.researchgate.net/publication/200450911/figure/fig1/AS%3A651219752202268%401532274296711/the-general-structure-for-x509-standard-certificate.png)

A TLS certificate is usually an **X.509** structure.

### Core fields (the essential organs)

**1. Subject**

* The identity being certified
* Example:

  ```
  CN=example.com
  ```

**2. Subject Alternative Names (SAN)**

* The *real* domain list browsers check
* Example:

  ```
  DNS: example.com
  DNS: www.example.com
  ```

**3. Public Key**

* RSA or ECDSA public key
* Used during key exchange

**4. Issuer**

* Which CA signed this certificate
* Example:

  ```
  CN=R3, O=Let's Encrypt
  ```

**5. Validity Period**

* `Not Before`
* `Not After`

**6. Signature Algorithm**

* Example:

  ```
  sha256WithRSAEncryption
  ```

**7. Digital Signature**

* Hash of all certificate fields
* Encrypted with CAâ€™s private key

---

## 5. Certificate chain (why one cert is never alone)

Browsers donâ€™t trust your server directly. They trust **root CAs**.

![Image](https://www.keyfactor.com/wp-content/uploads/Certificate20Chain20of20Trust-Sep-02-2020-08-15-34-33-PM.png)

![Image](https://www.thesslstore.com/blog/wp-content/uploads/2018/08/Certificate-Chain.jpg)

Typical chain:

```
Root CA (preinstalled in OS/browser)
   â†“
Intermediate CA
   â†“
Server Certificate (example.com)
```

Why intermediates exist:

* Root keys stay offline (safety)
* Intermediates do day-to-day signing

Your server usually sends:

* its own certificate
* intermediate certificates

The browser already has:

* root certificates

---

## 6. How browsers verify certificates (logic, not magic)

When the certificate arrives, the browser:

1. Checks domain name matches SAN
2. Checks expiry dates
3. Verifies signature:

   * Decrypts signature using CA public key
   * Recomputes hash
   * Compares
4. Builds trust chain up to a known root
5. Checks revocation (CRL / OCSP)

If *any* step fails â†’ scary red warning.

---

## 7. Key misconception to kill ðŸ”ª

**Certificates do NOT encrypt traffic.**

They only:

* prove identity
* securely bootstrap symmetric keys

Actual encryption uses:

* AES / ChaCha20
* Fast, symmetric crypto
* Keys derived during handshake

---

## 8. Networking mental model (keep this)

Think of TLS like this:

> TCP gives you a pipe
> TLS puts a locked box inside the pipe
> Certificates prove who owns the lock
> Symmetric keys do the heavy lifting

Once TLS is established, HTTP is just another byte stream riding inside encrypted TCP segments.

---

If you want, the next natural layer down is **packet-level TLS analysis**â€”looking at a real `ClientHello` and certificate in Wireshark and mapping fields to bytes. Thatâ€™s where theory snaps into place with satisfying *clicks*.
