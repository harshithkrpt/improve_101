DNS looks mundane on the surface—“names to numbers”—but under the hood it’s a beautifully layered piece of network plumbing. Let’s peel it from first principles and see how it really behaves.

---

## 1. What DNS is (from first principles)

Computers route packets using **IP addresses**. Humans, inconveniently, think in **names**. DNS (Domain Name System) is the globally distributed, hierarchical database that translates **human-readable names** like `api.example.com` into **machine-routable IP addresses** like `93.184.216.34`.

Two important subtleties often missed:

• DNS is **not a single server**. It’s a **federated system** of millions of servers cooperating under shared rules.
• DNS is **eventually consistent**, not instant truth. Caching is a feature, not a bug.

Think of DNS as the Internet’s phone book, but one where:

* Everyone keeps partial copies
* Entries expire (TTL)
* Authority is delegated top-down

---

## 2. Which layer DNS lives in

DNS lives at the **Application Layer**.

Why?
Because DNS deals in *meaningful data structures* (domain names, record types, TTLs), not raw packet delivery. Everything below it just moves bytes.

Typical stack:

```
DNS (Application)
UDP / TCP (Transport)
IP (Network)
Ethernet / Wi-Fi (Link)
```

Transport details matter:

* **UDP port 53** → default, fast, stateless
* **TCP port 53** → zone transfers, large responses, DNSSEC, truncation fallback
* **DoH (DNS over HTTPS)** → DNS inside HTTPS (port 443)
* **DoT (DNS over TLS)** → DNS inside TLS (port 853)

The protocol is the same; only the *envelope* changes.

---

## 3. How DNS is routed (resolution flow)

DNS routing is not packet routing—it’s **question routing** via delegation.

When your app asks:

> “What is the IP for `www.google.com`?”

Your machine doesn’t magically know. It asks, step by step, *who might know*.

![Image](https://www.researchgate.net/publication/342003872/figure/fig2/AS%3A900085244248066%401591608453435/Domain-name-resolution-process-with-DNS.ppm)

![Image](https://gaia.cs.umass.edu/kurose_ross/interactive/dns_query.png)

![Image](https://blog.theodo.com/_astro/dns-hierarchy.CNS-fnn7_2pDSH3.webp)

### The resolution chain (simplified)

1. **Stub Resolver**
   Your OS sends a query to a **recursive resolver** (ISP, router, or public DNS).

2. **Recursive Resolver**
   If cached → answer immediately.
   If not cached → starts walking the hierarchy.

3. **Root Server**
   “I don’t know `google.com`, but ask the `.com` servers.”

4. **TLD Server (.com)**
   “I don’t know `www.google.com`, but ask Google’s authoritative servers.”

5. **Authoritative Server**
   “Here is the A/AAAA record. This is the truth.”

6. **Caching on the way back**
   Resolver stores it for TTL seconds.

Key insight:
DNS **never routes data packets**, only **knowledge about where packets should go**.

---

## 4. How DNS looks on the wire (state, header, data)

DNS is deceptively compact. A full query often fits inside a single UDP packet.

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20220514144130/dnsquerymessage.png)

![Image](https://www.firewall.cx/images/stories/dns-response-format-9.gif)

![Image](https://www.tcpipguide.com/free/diagrams/dnsrrformat.png)

### DNS message structure

```
+---------------------+
| Header (12 bytes)   |
+---------------------+
| Question Section    |
+---------------------+
| Answer Section      |
+---------------------+
| Authority Section   |
+---------------------+
| Additional Section  |
+---------------------+
```

### Header (the brain stem)

Key fields:

* **Transaction ID** – matches response to request
* **Flags**

  * QR (query/response)
  * RD (recursion desired)
  * RA (recursion available)
  * TC (truncated)
* **Counts**

  * QDCOUNT – questions
  * ANCOUNT – answers
  * NSCOUNT – authority records
  * ARCOUNT – additional records

Stateless doesn’t mean brainless:
The transaction ID is how DNS pretends to be stateful over UDP.

---

### Question section

Example:

```
QNAME: www.google.com
QTYPE: A
QCLASS: IN
```

This is literally the question:
“Give me the IPv4 address for this name.”

---

### Resource Records (Answer / Authority / Additional)

Each record looks like:

```
NAME | TYPE | CLASS | TTL | RDLENGTH | RDATA
```

Examples:

* **A** → IPv4 address
* **AAAA** → IPv6 address
* **CNAME** → alias
* **NS** → authoritative name server
* **MX** → mail server

TTL is the quiet hero here—it defines how long lies are acceptable.

---

## A mental model worth keeping

DNS is:

* **Hierarchical** → authority flows downward
* **Distributed** → no central control
* **Cache-heavy** → performance over purity
* **Mostly stateless** → UDP-first design
* **Foundational** → almost every network interaction starts with it

If TCP is the conversation and IP is the road system, DNS is the act of *looking up the address before you leave the house*. No lookup, no journey.

From here, the really interesting rabbit holes are DNS caching pathologies, DNSSEC trust chains, and how CDNs weaponize DNS responses to steer traffic globally. The map gets stranger the deeper you go—and that’s where the fun starts.
