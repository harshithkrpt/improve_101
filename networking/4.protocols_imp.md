DNS looks mundane on the surface—“names to numbers”—but under the hood it’s a beautifully layered piece of network plumbing. Let’s peel it from first principles and see how it really behaves.

---

## 1. What DNS is (from first principles)

Computers route packets using **IP addresses**. Humans, inconveniently, think in **names**. DNS (Domain Name System) is the globally distributed, hierarchical database that translates **human-readable names** like `api.example.com` into **machine-routable IP addresses** like `93.184.216.34`.

Two important subtleties often missed:

• DNS is **not a single server**. It’s a **federated system** of millions of servers cooperating under shared rules.
• DNS is **eventually consistent**, not instant truth. Caching is a feature, not a bug.

Think of DNS as the Internet’s phone book, but one where:

* Everyone keeps partial copies
* Entries expire (TTL)
* Authority is delegated top-down

---

## 2. Which layer DNS lives in

DNS lives at the **Application Layer**.

Why?
Because DNS deals in *meaningful data structures* (domain names, record types, TTLs), not raw packet delivery. Everything below it just moves bytes.

Typical stack:

```
DNS (Application)
UDP / TCP (Transport)
IP (Network)
Ethernet / Wi-Fi (Link)
```

Transport details matter:

* **UDP port 53** → default, fast, stateless
* **TCP port 53** → zone transfers, large responses, DNSSEC, truncation fallback
* **DoH (DNS over HTTPS)** → DNS inside HTTPS (port 443)
* **DoT (DNS over TLS)** → DNS inside TLS (port 853)

The protocol is the same; only the *envelope* changes.

---

## 3. How DNS is routed (resolution flow)

DNS routing is not packet routing—it’s **question routing** via delegation.

When your app asks:

> “What is the IP for `www.google.com`?”

Your machine doesn’t magically know. It asks, step by step, *who might know*.

![Image](https://www.researchgate.net/publication/342003872/figure/fig2/AS%3A900085244248066%401591608453435/Domain-name-resolution-process-with-DNS.ppm)

![Image](https://gaia.cs.umass.edu/kurose_ross/interactive/dns_query.png)

![Image](https://blog.theodo.com/_astro/dns-hierarchy.CNS-fnn7_2pDSH3.webp)

### The resolution chain (simplified)

1. **Stub Resolver**
   Your OS sends a query to a **recursive resolver** (ISP, router, or public DNS).

2. **Recursive Resolver**
   If cached → answer immediately.
   If not cached → starts walking the hierarchy.

3. **Root Server**
   “I don’t know `google.com`, but ask the `.com` servers.”

4. **TLD Server (.com)**
   “I don’t know `www.google.com`, but ask Google’s authoritative servers.”

5. **Authoritative Server**
   “Here is the A/AAAA record. This is the truth.”

6. **Caching on the way back**
   Resolver stores it for TTL seconds.

Key insight:
DNS **never routes data packets**, only **knowledge about where packets should go**.

---

## 4. How DNS looks on the wire (state, header, data)

DNS is deceptively compact. A full query often fits inside a single UDP packet.

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20220514144130/dnsquerymessage.png)

![Image](https://www.firewall.cx/images/stories/dns-response-format-9.gif)

![Image](https://www.tcpipguide.com/free/diagrams/dnsrrformat.png)

### DNS message structure

```
+---------------------+
| Header (12 bytes)   |
+---------------------+
| Question Section    |
+---------------------+
| Answer Section      |
+---------------------+
| Authority Section   |
+---------------------+
| Additional Section  |
+---------------------+
```

### Header (the brain stem)

Key fields:

* **Transaction ID** – matches response to request
* **Flags**

  * QR (query/response)
  * RD (recursion desired)
  * RA (recursion available)
  * TC (truncated)
* **Counts**

  * QDCOUNT – questions
  * ANCOUNT – answers
  * NSCOUNT – authority records
  * ARCOUNT – additional records

Stateless doesn’t mean brainless:
The transaction ID is how DNS pretends to be stateful over UDP.

---

### Question section

Example:

```
QNAME: www.google.com
QTYPE: A
QCLASS: IN
```

This is literally the question:
“Give me the IPv4 address for this name.”

---

### Resource Records (Answer / Authority / Additional)

Each record looks like:

```
NAME | TYPE | CLASS | TTL | RDLENGTH | RDATA
```

Examples:

* **A** → IPv4 address
* **AAAA** → IPv6 address
* **CNAME** → alias
* **NS** → authoritative name server
* **MX** → mail server

TTL is the quiet hero here—it defines how long lies are acceptable.

---

## A mental model worth keeping

DNS is:

* **Hierarchical** → authority flows downward
* **Distributed** → no central control
* **Cache-heavy** → performance over purity
* **Mostly stateless** → UDP-first design
* **Foundational** → almost every network interaction starts with it

If TCP is the conversation and IP is the road system, DNS is the act of *looking up the address before you leave the house*. No lookup, no journey.

From here, the really interesting rabbit holes are DNS caching pathologies, DNSSEC trust chains, and how CDNs weaponize DNS responses to steer traffic globally. The map gets stranger the deeper you go—and that’s where the fun starts.

`nslookup` and `dig` are two different lenses on the same beast: DNS. One is an old Swiss-army knife that talks back; the other is a scalpel that shows you the wire-level truth. Let’s use both, hands-on, and decode what you’re actually seeing.

---

## nslookup — conversational, quick checks

Think of `nslookup` as *interactive DNS probing*. It’s handy for fast sanity checks and basic debugging.

### Basic lookup

```
nslookup google.com
```

Typical output (annotated mentally):

* **Server** → which DNS resolver answered you (ISP, router, 8.8.8.8, etc.)
* **Address** → IP of that resolver
* **Non-authoritative answer** → came from cache, not the source of truth
* **Name / Address** → resolved IPs

Non-authoritative is not an error. It’s DNS doing its caching job.

---

### Query a specific DNS server

```
nslookup google.com 8.8.8.8
```

This bypasses your system resolver and asks Google’s DNS directly. Useful when:

* Your ISP DNS is lying
* You want to compare answers across resolvers

---

### Ask for a specific record type

```
nslookup -type=MX gmail.com
```

You’re asking:

> “Where should email for this domain go?”

Try also:

```
nslookup -type=NS google.com
nslookup -type=TXT google.com
```

TXT records often hide SPF, DKIM, domain verification, and other internet secrets.

---

### Interactive mode

```
nslookup
> server 1.1.1.1
> set type=A
> openai.com
> exit
```

This is useful when you want to experiment without retyping commands.

---

## dig — truth serum for DNS

`dig` (Domain Information Groper) is what network engineers use when they want **no abstraction, no fluff**.

### Basic query

```
dig google.com
```

Ignore the wall of text at first. Focus on:

* **QUESTION SECTION** → what you asked
* **ANSWER SECTION** → what you got
* **Query time** → latency
* **SERVER** → who answered

Everything else is context.

---

### Short answer only

```
dig google.com +short
```

Perfect for scripts and quick checks:

```
142.250.195.78
```

---

### Ask for a specific record

```
dig google.com A
dig google.com AAAA
dig google.com MX
```

Each maps directly to DNS record types. No magic.

---

### Trace the DNS resolution path (gold-tier command)

```
dig google.com +trace
```

This shows **the entire delegation chain**:

* Root servers
* `.com` TLD servers
* Google’s authoritative servers

This is DNS thinking out loud. If something breaks, `+trace` usually tells you *where*.

---

### Query a specific DNS server

```
dig @8.8.8.8 google.com
```

The `@` means:

> “Ask this server directly, don’t involve my resolver.”

Great for debugging split-horizon DNS, VPN issues, or CDN behavior.

---

### See TTL and authoritative answers

```
dig google.com +noall +answer
```

Example:

```
google.com.  300  IN  A  142.250.195.78
```

That `300` is the TTL in seconds.
This number explains **why DNS changes feel slow**.

---

### Compare UDP vs TCP

```
dig google.com +tcp
```

DNS normally uses UDP. TCP appears when:

* Response is large
* DNSSEC is involved
* Truncation happens

If UDP fails and TCP works, you’ve learned something important.

---

## nslookup vs dig — when to use which

Use `nslookup` when:

* You want quick answers
* You’re on a minimal system
* You prefer interactive exploration

Use `dig` when:

* You want protocol-level clarity
* You’re debugging real DNS issues
* You care about TTLs, flags, authority, recursion

Professionally speaking:
`nslookup` asks *politely*.
`dig` interrogates.

---

## A useful mental habit

Whenever DNS feels “random,” run:

```
dig domain.com +trace
```

DNS almost never breaks randomly. It breaks **hierarchically**. This command shows you exactly where the chain snaps.

From here, the next natural curiosities are:

* Why CDNs return different IPs per location
* How DNS caching causes “it works on my machine”
* How DNSSEC adds cryptographic trust to this whole house of cards

DNS looks simple because it hides its complexity well. Tools like `dig` remind you that elegance is usually hard-won.
