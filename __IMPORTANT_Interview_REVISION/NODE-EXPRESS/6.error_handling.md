Node’s error handling is a small circus of “throw things, catch things, and occasionally watch things ignite.” Interviews love this because it tests whether you understand synchronous vs asynchronous control flow rather than how loudly you can shout `console.log`.

### Synchronous errors: the easy, boring part

Synchronous code is a simple universe. If something explodes, you can throw an error and catch it in a `try/catch`.

```js
function doStuff() {
  if (Math.random() > 0.5) throw new Error("Physics failed");
  return 42;
}

try {
  const x = doStuff();
} catch (err) {
  console.error("caught:", err);
}
```

The runtime pauses, jumps to the `catch` block, and keeps going. This is “blocking in spirit” even if Node tries to keep things event-y.

### Asynchronous errors: welcome to chaos

Async code splits time into “now” and “later”. `try/catch` cannot reach across time.

A classic trap:

```js
try {
  fs.readFile("data.txt", () => {
    throw new Error("NOPE");
  });
} catch (err) {
  console.log("won't catch", err);
}
```

The callback throws after the `try` block has already finished. Node will treat this as an uncaught exception, possibly killing the process, like a drama queen.

### Promises: the awkward teenagers of async

Promises introduced "failure as a value." Instead of throwing, they prefer rejecting.

```js
promiseFn()
  .then(result => handle(result))
  .catch(err => console.log("caught:", err));
```

This is the entire point of `.catch()`.

### `try/catch` with async/await

`async/await` is syntactic sugar over promises, designed to rescue our sanity. Not a perfect rescue, but better than callback hell.

```js
async function dance() {
  try {
    const result = await promiseFn();
  } catch (err) {
    console.error("caught:", err);
  }
}
```

Nice and readable. The trick: errors thrown *inside* the awaited promise act like synchronous throws in that block.

### Mixing promises and `try/catch`: existential dread

The trap is: `try/catch` only catches promise rejections during `await`.
Anything you don’t `await` becomes feral.

```js
try {
  promiseFn(); // no await
} catch {
  // will never catch
}
```

This is like throwing a boomerang into another dimension.

### Global error handlers: last-resort duct tape

Node gives you emergency nets:

1. `process.on('uncaughtException')`
   Fires when nobody caught a synchronous throw.

2. `process.on('unhandledRejection')`
   Fires when a promise rejected without `.catch()`.

```js
process.on("unhandledRejection", (err) => {
  console.error("promise meltdown", err);
});
```

These should log, cleanup, and kill the process.
People who keep the app running after fatal errors are flirting with undefined behavior. That’s the software equivalent of driving a car after removing all the wheels.

### Express-style centralized error handling

Frameworks hide pain with middleware.

```js
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ message: "kaboom" });
});
```

And if you want an async handler:

```js
const wrap = fn => (req, res, next) =>
  Promise.resolve(fn(req, res, next)).catch(next);
```

This prevents every controller looking like a noir novel full of `try/catch`.

### Philosophy-ish conclusion (because the universe is daft)

Error handling in Node is about taming time. Sync errors happen “now,” async errors happen “later,” and promises give “later” its own logic. Interviews want to see if you understand that `try/catch` is a spatial construct, promise errors are value-based, and global handlers are last rites.

A useful direction from here is exploring how distributed systems make error handling not just a matter of code, but a matter of sociology.
