CommonJS and ESM are two module systems in JavaScript that sit next to each other like awkward cousins at a family reunion. They both solve “how do I split code across files?” but they were born in different eras.

---

### CommonJS (CJS)

This is the older Node-native format.

Syntax:

```js
const x = require('./x')
module.exports = y
```

Behavior:

* Loading is **synchronous**; Node reads and executes immediately.
* Modules are **mutable objects**; you can change exports.
* `require` executes code **once** and caches it. Subsequent requires return from cache.
* Works only in Node unless bundled.

Philosophically, it’s the grumpy uncle: pragmatic, fast, doesn’t care about standards.

---

### ECMAScript Modules (ESM)

The shiny standardized thing JavaScript got in 2015.

Syntax:

```js
import x from './x.js'
export default y
```

Behavior:

* Loading is **asynchronous**; imports are resolved before execution.
* Static analysis: tools know imports/exports at parse time.
* Exports are **immutable bindings**; the reference can’t change, though underlying object can.
* Native in modern browsers and newer Node.

This is the idealist cousin who believes in world peace and tree-shaking.

---

### Node’s “two systems living together” mess

Node supported CommonJS for years. ESM arrived late, so we ended up with compatibility quirks.

Node decides module type by:

1. File extension:
   `.mjs` = ESM
   `.cjs` = CommonJS
2. Or `package.json`:

   ```json
   { "type": "module" }
   ```

   Then `.js` files are ESM by default.

If no `"type": "module"` → `.js` = CommonJS.

---

### Importing between the two

This is where the spaghetti comes in.

ESM → CJS:

```js
import pkg from './thing.cjs'
// default import represents module.exports
```

CJS → ESM:

```js
const pkg = require('./thing.mjs')
// but you can’t destructure named exports directly
```

ESM has **live bindings**, CommonJS exports a **snapshot**, so interop can feel like duct-taping two different animal species together.

---

### import/export quirks you’re likely to hit

1. **Default vs named exports**

```js
export default foo
export const bar = 1
```

Consumer:

```js
import foo, { bar } from './mod.js'
```

Mixing default and named can get weird in CJS interop because CJS doesn’t have native named exports.

---

2. **require is not allowed in ESM by default**

```js
// ❌
const x = require('fs')
```

Instead you do:

```js
import fs from 'node:fs'
```

Or:

```js
import { createRequire } from 'module'
const require = createRequire(import.meta.url)
```

Notice how ESM made you write a spell just to simulate require.

---

3. **JSON imports**
   In CommonJS:

```js
const data = require('./data.json')
```

In ESM:

```js
import data from './data.json' assert { type: 'json' }
```

Optional in newer Node, but historically annoying.

---

4. **Dynamic import**
   CommonJS:

```js
const mod = require(path)
```

ESM:

```js
const mod = await import(path)
```

This works everywhere and is useful when you want conditional loading.

---

### Why ESM matters in modern Node

Because tools can:

* Tree-shake (remove unused code)
* Optimize bundling
* Analyze dependencies statically
* Enable top-level `await`

Also, browser and server can finally share syntax without translation.

---

### Migration advice for a sane codebase

For real-world 3-years experience, you’re not expected to philosophize about module metaphysics. The useful guideline is:

* If your project is new: **use ESM**
* If old and working: **don’t touch it unless forced**
* When mixing: **hide CJS ↔ ESM interop behind a wrapper file**

Purity is for priests, not engineers shipping features.

---

### Quick mental cheat-sheet

CJS:

* `require`, `module.exports`
* sync
* Node-only
* mutable
* works everywhere in legacy code

ESM:

* `import`, `export`
* async
* standard
* static
* better tooling

---

Modules are one of those everyday details that look trivial but hide an entire evolutionary story of JavaScript trying to pretend it had a plan. Examining the mess reveals how software ecosystems grow: not through elegance, but through stubborn compatibility layered over aspiration.
