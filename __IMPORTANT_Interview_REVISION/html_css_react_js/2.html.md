

## HTML

### Semantic HTML5 tags (`header`, `nav`, `main`, `section`, `article`, `aside`, `footer`)

Semantic tags make your HTML more readable and accessible (for both developers and assistive technologies like screen readers).

| Tag         | Meaning / Purpose                                                                                                           | Common Usage Example                                                   |
| ----------- | --------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| `<header>`  | Represents the **introductory section** of a page or a section. Usually contains logos, navigation, titles, or search bars. | `html<br><header><h1>My Blog</h1><nav>...</nav></header>`              |
| `<nav>`     | Defines a **section for navigation links** (menus, tables of contents, etc.).                                               | `html<br><nav><a href="/">Home</a> <a href="/about">About</a></nav>`   |
| `<main>`    | Contains the **main content** unique to the page. There should be only **one `<main>`** per page.                           | `html<br><main><article>...</article></main>`                          |
| `<section>` | Groups related content under a **thematic grouping**, usually with its own heading. Think of it as a ‚Äúchapter.‚Äù             | `html<br><section><h2>Features</h2><p>Details...</p></section>`        |
| `<article>` | Represents **self-contained content** that could stand alone ‚Äî like a blog post, news article, or forum entry.              | `html<br><article><h2>Post Title</h2><p>Post content...</p></article>` |
| `<aside>`   | Contains **indirectly related content** ‚Äî sidebars, ads, related links, etc.                                                | `html<br><aside><h3>Related Posts</h3><ul>...</ul></aside>`            |
| `<footer>`  | Represents the **footer section** of a page or a section. Commonly includes author info, copyright, or contact links.       | `html<br><footer><p>¬© 2025 My Blog</p></footer>`                       |

- improves accessibility
- seo friendlt
- maintainability
- standard structure


### Forms: validation attributes (`required`, `pattern`, `novalidate`)

- HTML forms are used to collect user input and send it to a server for processing.


```html
<form action="/submit" method="POST">
  <label for="name">Name:</label>
  <input type="text" id="name" name="username" required>

  <label for="email">Email:</label>
  <input type="email" id="email" name="useremail">

  <button type="submit">Submit</button>
</form>
```

#### Key Attributes of <form>

- action: URL where form data is sent.

- method: HTTP method ‚Äî "GET" (appends data to URL) or "POST" (sends in body).

- target: Where to display the response (_self, _blank, _parent, _top).

- novalidate: Disables browser‚Äôs built-in validation.

#### Form Validation Attributes

1. required

- ensures field must be filled before submiting
```html
<input type="text" name="username" required>
```

2. pattern 

- ensures a field must match a regex

```html
<input type="text" pattern="[A-Za-z]{3,10}" title="Enter 3‚Äì10 letters only">

```

3. novalidate

- placed on form to disable html5 validation and add from js

```html
<form novalidate>
    <label for="name" >Name</label>
    <input type="text" id="name" name="username" />

    <button type="submit">Submit</button>
</form>
```


### - Accessibility (a11y): `aria-label`, roles, tab order, landmarks

- developing webcontent for everyone including disablities , (visual , auditory, motor, cognitive)

1. aria label

- adds a text label to the screen readers like icons where text is not available

```html
<button aria-label="Search Button">
    <svg>...</svg> 
</button>
```

- aria-labelledby ‚Üí references another element as its label.
- aria-describedby ‚Üí adds extra descriptive info (like tooltips).

2. role

- we can make few non semantic html elements act as our intended ones using role

```html
<div role="button" tabindex="0">Click me</div>
```

- Use native HTML elements (like <button>, <nav>) whenever possible ‚Äî add role only when necessary.

3. tab order

- Keyboard users navigate using the Tab key.

- tabindex="0" ‚Üí Makes an element focusable in normal tab order.
- tabindex="-1" ‚Üí Makes an element focusable via JavaScript, not by tab.
- tabindex="positive number" ‚Üí Sets custom order (avoid unless necessary).

```html
<button>1</button>
<button tabindex="2">3</button>
<button tabindex="1">2</button>

```

4. Landmarks

- Landmarks help screen readers navigate major page sections quickly.
- tools like axe will help us in making these changes


### - SEO: meta tags, title, canonical, Open Graph

- SEO (Search Engine Optimization) helps search engines understand your webpage‚Äôs content and improve its visibility in search results.

1. <title> tag

- Defines the title of the page ‚Äî displayed in browser tabs and search engine results.

2. <meta> tag

- Meta tags give metadata (information about the page) to browsers and search engines.

- meta dscription

```html
<meta name="description" content="Learn easy homemade pizza recipes with step-by-step guides.">
```

- meta robots

```html
<meta name="robots" content="index, follow">
```

- index , noindex -> whether to index this page or not
- follow, nofollow -> whether to follow the index or not

3. Canonical Tag (<link rel="canonical">)

```html
<link rel="canonical" href="https://example.com/pizza-recipes">
```

- If your page is accessible at multiple URLs (e.g., /pizza and /pizza?ref=homepage), the canonical tag ensures only one version is indexed.


4. Open Graph (OG) Tags

- Used mainly by social media platforms (Facebook, LinkedIn, X/Twitter) to display rich previews when links are shared.

```html
<meta property="og:title" content="Best Pizza Recipes">
<meta property="og:description" content="Discover delicious homemade pizza recipes with fresh ingredients.">
<meta property="og:image" content="https://example.com/pizza.jpg">
<meta property="og:url" content="https://example.com/pizza-recipes">
<meta property="og:type" content="article">
```


### - `<script>` attributes: `defer` vs `async`

- Let‚Äôs break down everything about the <script> tag, especially defer, async, and how scripts are imported and executed in the browser.

1. <script> tag 

- used to load and execute javascript on a web page

```html
<script src="app.js"></script>
```

- what above does
    - pauses html parsing
    - downloads & executes the script immediately
    - then resumes rendering

- so these always block rendering 


2. defer attribute

```html
<script src="main.js" defer></script>
```

- behaviour: 
    - scripts downloads in parallel to html parsing
    - executes only after the html is fully parsed but before DOMContentLoaded
    - execution order is preserved

- Use when:
    - Your script depends on the DOM being ready
    - Scripts must execute in sequence
    - You want non-blocking but ordered execution


3. async attribute

```html
<script src="analytics.js" async></script>
```

- behavior:
    - script downloads in parallel with html parsing
    - exexutes as soon as it finishes downloading without waiting for html 
    - execution order is not guaranteed

‚úÖ Use when:

Script is independent (no DOM or other script dependency)

Example: analytics, ads, or tracking scripts

```html
<script src="a.js" async></script>
<script src="b.js" async></script>

```

#### comparision

| Attribute | HTML Parsing | Script Download | Script Execution        | Execution Order | Use Case                   |
| --------- | ------------ | --------------- | ----------------------- | --------------- | -------------------------- |
| *(none)*  | Blocked      | Sequential      | Immediately when loaded | Preserved       | Inline or critical scripts |
| `defer`   | Continues    | Parallel        | After HTML parsing      | Preserved       | DOM-dependent scripts      |
| `async`   | Continues    | Parallel        | As soon as loaded       | Unpredictable   | Independent scripts        |


4. inline scripts

```html
<script>
  console.log("Hello world");
</script>
```

- runs immediately during parsing


5. ES Modules (type="module")

- Modern browsers support JavaScript modules, allowing import and export between files.

```html
<script type="module" src="main.js"></script>
```

- Automatically deferred (acts like defer by default)
- Supports imports and exports
- Each module has its own scope (not global)
- import paths must be absolute or relative URLs

```js
// main.js
import { greet } from './utils.js';
greet();
```

```js
// utils.js
export function greet() {
  console.log('Hello from module!');
}

```

7. Key Interview Insights

Which loads first ‚Äî async or defer?
‚Üí Both download in parallel.

async executes immediately when ready

defer waits until HTML parsing completes

What if both async and defer are present?
‚Üí Browser will treat it as async (defer ignored).

How does DOMContentLoaded interact?

defer scripts run before DOMContentLoaded

async scripts may run before or after ‚Äî unpredictable

Are module scripts blocking?
‚Üí No, type="module" scripts are deferred by default.

What happens if you put scripts at the end of <body>?
‚Üí Similar effect to defer: HTML is already parsed, so no blocking.


### - Storage: LocalStorage vs SessionStorage vs Cookies

All three store data in the browser ‚Äî but differ in lifetime, scope, and usage.

| Feature             | **localStorage**                         | **sessionStorage**         | **Cookies**                                |
| ------------------- | ---------------------------------------- | -------------------------- | ------------------------------------------ |
| **Storage Limit**   | ~5‚Äì10 MB                                 | ~5 MB                      | ~4 KB                                      |
| **Persistence**     | Until manually cleared                   | Until browser/tab closes   | Can have expiration date                   |
| **Accessible From** | Any tab of same origin                   | Only current tab/window    | Both client (JS) and server (HTTP headers) |
| **Sent to Server?** | ‚ùå No                                     | ‚ùå No                       | ‚úÖ Yes (on every request)                   |
| **API**             | `localStorage.getItem()`                 | `sessionStorage.getItem()` | `document.cookie`                          |
| **Use Case**        | Save user settings, tokens, caching data | Temporary UI state per tab | Authentication, session tracking           |


### - Shadow DOM and Web Components

- Web Components

A set of modern browser APIs that allow you to create reusable, encapsulated custom elements ‚Äî like your own <date-picker> or <modal-dialog>.

They consist of:

Custom Elements ‚Äì define your own tags.
Shadow DOM ‚Äì encapsulates styles and DOM structure.
HTML Templates ‚Äì reusable HTML chunks.


```js
class MyButton extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'open' });
    shadow.innerHTML = `
      <style>
        button { background: purple; color: white; border: none; }
      </style>
      <button>Click Me</button>
    `;
  }
}
customElements.define('my-button', MyButton);
```


### Critical Rendering Path (CRP)

- The Critical Rendering Path is the sequence of steps the browser takes to convert HTML, CSS, and JS into pixels on the screen.
- It affects how fast your page becomes visible and interactive.

Steps : 
1. HTML Parsing -> DOM Tree
2. CSS Parsing -> CSSOM Tree
3. DOM + CSSOM -> Render Tree
4. Layout (calculate positiions / sizes)
5. Paint
6. Composite

- optimisation techniques
  - minimise render blocking
    - use link rel="preload" , script defer for js
  - reduce css complexity and size
  - inline critical css
  - lazy load images & non critical scripts
  - Use HTTP/2 or CDNs to reduce latency.

```html
<head>
  <link rel="preload" href="styles.css" as="style">
  <link rel="stylesheet" href="styles.css">
  <script src="main.js" defer></script>
</head>
```

Interview Question Angles

What blocks the CRP? ‚Üí Render-blocking CSS/JS.

How to reduce First Paint / First Contentful Paint times?

How do async and defer differ?


### ‚öôÔ∏è 1. <link rel="preload"> vs <link rel="prefetch">

Both are resource hints that instruct the browser how and when to load resources ‚Äî but they serve different timing purposes.

| Feature                        | **preload**                                       | **prefetch**                                          |
| ------------------------------ | ------------------------------------------------- | ----------------------------------------------------- |
| **When used**                  | During current navigation (critical resources)    | For future navigations or routes (predictive loading) |
| **Priority**                   | **High** ‚Äî blocks rendering if needed             | **Low** ‚Äî background loading                          |
| **Use case**                   | Fonts, CSS, JS needed **immediately**             | Next-page assets, images, routes                      |
| **Browser behavior**           | Loads *now*, makes available in cache immediately | Loads *in background*, caches for later               |
| **Affects performance metric** | Improves **First Contentful Paint (FCP)**         | Improves **Subsequent Navigation** speed              |


```html
<!-- Preload: used for current page -->
<link rel="preload" href="/main.css" as="style">
<link rel="preload" href="/app.js" as="script">

<!-- Prefetch: used for next page -->
<link rel="prefetch" href="/next-page.js" as="script">

```

- as attribute tells the browser what kind of resource it is (important for prioritization & CORS).
- Misusing preload (too many) can actually hurt performance ‚Äî it competes with critical resources.
- Common strategy: preload critical, prefetch future.


### üß† 2. How Browsers Parse HTML ‚Üí DOM

This is a core browser pipeline concept. The DOM (Document Object Model) isn‚Äôt ‚Äúloaded all at once‚Äù; it‚Äôs built incrementally as the HTML is parsed.

1. HTML bytes received ‚Üí converted to characters
2. Tokenizer: characters ‚Üí tokens
  - Converts raw text into tokens like <html>, <div>, </p>.
3. Tree Constructor: tokens ‚Üí DOM nodes
  - The tokens are converted into nodes and linked hierarchically into the DOM tree.
4. External resources
  - <link> and <script> tags trigger resource fetching in parallel.
5. CSS Parsing
  - CSS is parsed into the CSSOM (CSS Object Model).
6. Render Tree
  - DOM + CSSOM ‚Üí Render Tree, excluding non-visual nodes (like <head>, display: none).
7. Layout + Paint + Composite
  - Layout computes geometry, Paint fills pixels, and Composite merges layers into what you see.

IMP : 
  - A synchronous <script> tag halts parsing.
  - Use defer to execute after parsing or async to execute when downloaded.

### üß© 3. CSR vs SSR ‚Äî HTML Structures and Rendering Pipeline

- Client Side Rendering

Who renders HTML? The browser, using JavaScript (usually React/Vue).

1. Browser gets a minimal HTML skeleton:

```html
<body>
  <div id="root"></div>
  <script src="/bundle.js"></script>
</body>

```

2. JS executes, builds virtual DOM, and injects full UI dynamically. 
3. Initial load = blank screen ‚Üí JS fetch ‚Üí UI render.


Pros:

Great interactivity after load.

Easy routing and state management.

Efficient after first render.

Cons:

Slow first paint (FCP/TTI) ‚Äî blank screen until JS runs.

Poor SEO if bots can‚Äôt execute JS (though Google can handle it now).

Large JS bundles hurt slow networks.

- Server Side Rendering

- Who renders HTML? The server.
  - Server generates fully rendered HTML string.


```html
<body>
  <div id="root">
    <h1>Welcome, Alice</h1>
    <p>Server rendered content</p>
  </div>
  <script src="/bundle.js"></script>
</body>

```
  
  - Browser displays meaningful content immediately.
  - JS ‚Äúhydrates‚Äù the page ‚Äî attaching event listeners and making it interactive.

Pros:

Fast initial render and SEO-friendly.

Better perceived performance.

Cons : 

Higher server load.

Slight delay during hydration (HTML ‚Üí React).

Hybrid Models

SSR + Hydration (Next.js) ‚Üí Pre-render + make interactive.

SSG (Static Site Generation) ‚Üí Build once, serve static HTML (e.g., blogs).

ISR (Incremental Static Regeneration) ‚Üí Update pages periodically without rebuilding all.

