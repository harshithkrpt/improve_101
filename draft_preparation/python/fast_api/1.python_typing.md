# üêç Python Type Hints Cheat Sheet (with FastAPI in mind)

## ‚ú® Basics
```python
def get_full_name(first_name: str, last_name: str) -> str:
    return first_name.title() + " " + last_name.title()
```

- `param: type` ‚Üí declares parameter type  
- `-> type` ‚Üí declares return type  
- Hints don‚Äôt change runtime behavior (just help tools, editors, FastAPI).

---

## üé≠ Simple Types
- `int`
- `float`
- `str`
- `bool`
- `bytes`

```python
def example(a: int, b: float, c: bool, d: bytes) -> str:
    return str(a + b) + str(c) + d.decode()
```

---

## üì¶ Collections (Generics)
Use **square brackets** to specify inner types.

### Python 3.8+
```python
from typing import List, Dict, Set, Tuple

def process_items(
    items: List[str],
    prices: Dict[str, float],
    tags: Set[bytes],
    coordinates: Tuple[int, int, str]
):
    ...
```

### Python 3.9+
```python
def process_items(items: list[str], prices: dict[str, float]):
    ...
```

---

## üîÄ Unions & Optionals
### Multiple possible types
```python
from typing import Union
def process_item(item: Union[int, str]):
    ...
```

Python 3.10+ sugar:
```python
def process_item(item: int | str):
    ...
```

### Possibly `None`
```python
from typing import Optional
def say_hi(name: Optional[str] = None):
    ...
```

Better explicit:
```python
def say_hi(name: str | None = None):
    ...
```

---

## üßë‚Äçüéì Classes as Types
```python
class Person:
    def __init__(self, name: str):
        self.name = name

def get_person_name(one_person: Person) -> str:
    return one_person.name
```

---

## üß© Pydantic Models
Data validation + parsing with types.
```python
from datetime import datetime
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str = "John Doe"
    signup_ts: datetime | None = None
    friends: list[int] = []

user = User(id="123", signup_ts="2020-01-01 12:00", friends=[1, "2", b"3"])
print(user)  
# User(id=123, name='John Doe', signup_ts=datetime.datetime(...), friends=[1, 2, 3])
```

---

## üè∑Ô∏è Annotated (Metadata in Types)
Extra metadata alongside types.  
```python
from typing_extensions import Annotated

def say_hello(name: Annotated[str, "metadata"]) -> str:
    return f"Hello {name}"
```
- First arg = actual type.  
- Rest = metadata (used by FastAPI, validators, docs).  

---

## üöÄ Why FastAPI Loves Type Hints
With just type hints, FastAPI can:
- **Validate** request data automatically  
- **Convert** inputs to proper types  
- **Generate docs** (OpenAPI, Swagger UI)  
- **Give editor autocomplete + type checks**

Example:
```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    price: float
    tags: list[str] = []

@app.post("/items/")
def create_item(item: Item):
    return item
```

Result:  
- Invalid requests auto-rejected with JSON error.  
- `/docs` ‚Üí auto-generated Swagger UI.  
- You wrote almost no boilerplate.

---

## üìù Quick Mind Map
- Use **basic types** (int, str, float, bool, bytes).  
- Use **Generics** for containers (list[str], dict[str, float]).  
- Use **Union / |** when multiple types possible.  
- Use **Optional / | None** for nullable values.  
- Use **classes** and **Pydantic models** for structured data.  
- Use **Annotated** for extra metadata.  
