# Node.js Learn – Comprehensive Guide

## Getting Started with Node.js

### Introduction to Node.js
Node.js is an open-source, cross-platform JavaScript runtime environment, powered by Chrome’s V8 engine, that allows JavaScript to run outside a browser. It uses an event-driven, non-blocking I/O model, making it efficient and scalable for real-time applications. Unlike traditional multithreaded servers, a Node.js app runs on a **single thread**; concurrency is achieved via asynchronous I/O – when one operation (like file or network access) is in progress, Node can process other events rather than idling. This means Node can handle thousands of concurrent connections without spawning new threads for each request. Another key advantage is that front-end developers who know JavaScript can leverage those skills on the server side as well.

**Example – A Simple HTTP Server:** The classic “Hello World” example in Node is creating a web server:

```js
const { createServer } = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

**Best Practices:**
- Prefer asynchronous APIs (e.g., `fs.readFile`) over synchronous ones (`fs.readFileSync`) to keep the event loop responsive.
- Always handle errors in callbacks, promises, and async/await (`try/catch`).
- Use the latest LTS version of Node.js for stability and security.

**Good to Know:**
- Node ships quickly with modern JS features via the V8 engine—upgrade Node to access newer ECMAScript capabilities.
- Node has a rich standard library (e.g., `fs`, `http`) and an enormous ecosystem via npm.

---

### How Much JavaScript Do You Need to Know?
Since Node.js uses JavaScript, solid JS fundamentals are essential: variables, types, functions, classes, modules, closures, scopes, async patterns (callbacks, Promises, async/await), and the event loop.

**Best Practices:**
- Learn Node’s globals (`global`, `process`) and the module systems (CommonJS and ES Modules).
- Prefer modern JS syntax (ES2015+) and async/await for clean async code.

**Good to Know:** Browser-specific APIs like `window`/`document` do not exist in Node. Learn Node’s equivalents and APIs.

---

### Differences Between Node.js and the Browser
- No DOM or browser APIs in Node (no `window`, `document`, `alert`). Instead, Node provides modules for file system, networking, etc.
- You control the runtime version in Node, so you can rely on consistent language support.
- Node supports both **CommonJS** (`require`) and **ES Modules** (`import`).

**Best Practices:**
- Don’t assume browser globals are present.
- For isomorphic code, use environment/feature detection.

**Good to Know:** Many libraries ship separate builds for Node and the browser, or adapt automatically.

---

### The V8 JavaScript Engine
V8 compiles JavaScript to machine code (JIT) for speed. Node updates its V8 version regularly, bringing performance improvements and new JS features.

**Best Practices:**
- Avoid long, CPU-bound synchronous work on the main thread; prefer async patterns or offload heavy work.

**Good to Know:** `node -p process.versions.v8` prints the V8 version used by your Node.

---

### npm (Node Package Manager)
Use npm (or Yarn/pnpm) to install and manage dependencies via `package.json`.

**Common Commands:**
- Install project deps: `npm install`
- Add a dependency: `npm install express`
- Add a devDependency: `npm install -D jest`
- Update deps: `npm update`
- Run scripts: `npm run <script>`

**Best Practices:**
- Pin or constrain versions (semver) to avoid surprise breaking changes.
- Use `npm audit` and keep dependencies updated.
- Don’t commit `node_modules` to source control.

**Good to Know:** Alternatives like Yarn/pnpm use the npm registry but offer different workflows/performance.

---

### ECMAScript 2015+ in Node
Modern Node supports most ES2015+ features without flags. Avoid `--harmony` in production; stick to features supported by your minimum Node version.

**Best Practices:**
- Don’t rely on experimental flags in production.
- For older Node targets, transpile with Babel/TypeScript if needed.

**Good to Know:** Use resources like node.green to check feature support per Node version.

---

### Development vs Production
`NODE_ENV` is a common convention for toggling behaviors (logging, debugging). Node itself doesn’t change core behavior based on it.

**Best Practices:**
- Set `NODE_ENV=production` in production deployments.
- Don’t bury logic differences deep in code paths based solely on env; prefer explicit configuration.

**Good to Know:** Follow Twelve-Factor App guidelines—config via environment variables.

---

### WebAssembly (Wasm) in Node
Run `.wasm` modules for near-native performance, often compiled from C/C++ or Rust.

**Example:**

```js
const fs = require('node:fs');
const wasmBuffer = fs.readFileSync('add.wasm');
const { instance } = await WebAssembly.instantiate(wasmBuffer);
console.log(instance.exports.add(5, 6)); // 11
```

**Best Practices:**
- Use Wasm for CPU-intensive tasks; keep JS↔Wasm boundaries chunky to minimize call overhead.

**Good to Know:** WASI enables controlled OS interactions from Wasm modules in Node.

---

### Debugging Node.js
Use the Inspector (`node --inspect` / `--inspect-brk`) and connect via Chrome DevTools or VS Code.

**Best Practices:**
- Never expose the inspector on public interfaces in production—use SSH tunnels if needed.
- Combine logging with debugger; use source maps for TypeScript.

**Good to Know:** `node --inspect` listens on 127.0.0.1:9229 by default.

---

### Profiling Node.js
CPU profile with `--prof` / `--cpu-prof`; analyze hot paths and avoid blocking the event loop.

**Best Practices:**
- Reproduce realistic load when profiling.
- Offload heavy CPU to worker threads or async native methods.

**Good to Know:** Flame graphs help visualize hotspots; tools like Clinic.js, 0x, and DevTools are handy.

---

### Fetch (Undici) in Node
Node 18+ includes global `fetch()` powered by Undici.

**Example GET:**

```js
const res = await fetch('https://jsonplaceholder.typicode.com/posts');
if (!res.ok) throw new Error(res.statusText);
const data = await res.json();
```

**Example POST:**

```js
const res = await fetch('https://example.com/api', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ hello: 'world' })
});
```

**Best Practices:**
- Use `AbortController` for timeouts.
- Stream large responses.

**Good to Know:** No browser cookie jar; manage cookies/headers manually.

---

### WebSocket Client in Node
Node 21+/22.4 ships a WebSocket client API similar to browsers.

```js
const socket = new WebSocket('ws://localhost:8080');
socket.addEventListener('open', () => socket.send('hello'));
socket.addEventListener('message', e => console.log(e.data));
```

**Best Practices:**
- Handle `close` and `error`; implement reconnection strategies if needed.

**Good to Know:** Built-in API is client-side; for servers, use libraries like `ws` or frameworks.

---

### Security Best Practices
- **DoS:** Set request size limits, timeouts, and use reverse proxies.
- **Debugger exposure:** Don’t enable inspector on production public interfaces.
- **Secrets:** Keep out of code and package tarballs; use env vars and `.npmignore`/`files` fields.
- **Request smuggling:** Keep secure HTTP parser; normalize headers at proxies.
- **Timing attacks:** Use `crypto.timingSafeEqual` for secret comparisons.
- **Supply chain:** Pin versions, review updates, run `npm audit`.
- **Prototype pollution:** Sanitize merges; consider `Object.create(null)` for dictionaries.

**Good to Know:** Consider `--frozen-intrinsics` to prevent monkey patching built-ins.

---

## Working with TypeScript in Node.js

### Intro to TypeScript
TypeScript adds optional static types, improving DX and catching errors earlier.

```ts
type User = { name: string; age: number };
function isAdult(u: User): boolean { return u.age >= 18; }
```

**Best Practices:**
- Enable `"strict": true` in `tsconfig.json`.
- Use `@types/*` packages (e.g., `@types/node`).

**Good to Know:** Types are erased at runtime—validate untrusted inputs.

---

### Running TypeScript Natively (Experimental)
Recent Node versions can strip types at runtime for `.ts` files.

**Best Practices:**
- Still run `tsc --noEmit` in CI to catch type errors.
- For production, consider a build step until native support is fully stable.

**Good to Know:** Native stripping ignores `tsconfig`—it’s not full type-checking.

---

### Runners (ts-node, tsx)
- **ts-node**: runs TS with type-checking (or `--transpile-only` for speed).
- **tsx**: super-fast transpile-only execution.

**Best Practices:**
- Use runners in dev; compile for production or run `tsc --noEmit` in CI.

---

### Transpile then Run
Traditional approach: `tsc` compiles TS to JS; run the JS with Node.

**Best Practices:**
- Use watch mode (`tsc -w`) and source maps.
- Emit declarations for libraries.

**Good to Know:** Combine with Nodemon or PM2 for auto-restart during dev.

---

## Files & Folders (fs, path)

### File Stats
```js
const { stat } = require('node:fs/promises');
const s = await stat('file.txt');
console.log(s.size, s.isFile(), s.mtime);
```

### File Paths
```js
const path = require('node:path');
const full = path.join(__dirname, 'data', 'info.txt');
```

### File Descriptors
```js
const fsp = require('node:fs/promises');
const fh = await fsp.open('log.txt', 'a');
await fh.writeFile('entry\n'); await fh.close();
```

### Reading & Writing
```js
const fs = require('node:fs');
fs.readFile('data.txt', 'utf8', (e, d) => { if (e) throw e; console.log(d); });
fs.writeFile('out.txt', 'Hello\n', e => { if (e) throw e; });
```

**Streams:**
```js
const rs = fs.createReadStream('big.file');
const ws = fs.createWriteStream('copy.file');
rs.pipe(ws);
```

**Best Practices:**
- Prefer async APIs.
- Use streams for large files and pipe to handle backpressure.

---

## Command Line Usage

### Run Scripts
`node app.js` or add a shebang (`#!/usr/bin/env node`) and make executable.

### Env Vars
```js
const env = process.env.NODE_ENV ?? 'development';
```

### REPL
Run `node` for interactive shell; use `.help`, `.editor`, `.exit`.

### CLI Input/Output
- Args: `process.argv.slice(2)`
- stdin/stdout:
```js
process.stdin.on('data', chunk => {/*...*/});
process.stdout.write('message\n');
```

**Best Practices:**
- Use libraries (yargs, prompts) for robust CLIs.
- Exit with proper codes (`process.exit(1)` on errors).

---

## Modules & Publishing

### CommonJS vs ES Modules
- CJS: `const x = require('./x')`
- ESM: `import x from './x.js'` (use `"type":"module"` or `.mjs`)

### Publishing to npm
- Prepare `package.json`, README, license.
- Control contents with `.npmignore` or `"files"`.
- Use semver; `npm publish` after `npm login`.

**Dual Packages (CJS + ESM) via `exports`:**
```json
"exports": {
  ".": { "require": "./dist/index.cjs", "import": "./dist/index.mjs" }
}
```

### Native Addons & N-API
Use Node-API for ABI stability across Node versions; provide prebuilt binaries when possible.

---

## HTTP Transactions
Create servers with `http.createServer`, read `req.method`, `req.url`, `req.headers`, and write response with `res.statusCode`, `res.setHeader()`, `res.end()`.

**Best Practices:**
- Set correct `Content-Type`.
- Handle errors and large request bodies safely.
- Prefer frameworks (Express/Fastify) for routing/middleware.

---

## Streams & Backpressure

### Streams
Readable, Writable, Duplex, Transform; use `.pipe()` to connect streams and automatically handle flow control.

### Backpressure
Respect `writable.write()` return value:
```js
let ok = writable.write(chunk);
if (!ok) writable.once('drain', () => writable.write(nextChunk));
```

**Best Practices:**
- Always handle `'error'` on streams.
- Tune `highWaterMark` only when necessary.

---

## Diagnostics

### Memory
Use DevTools heap snapshots, `process.memoryUsage()`, and look for leaks (dangling timers/listeners, growing caches).

### Live Debugging
Attach inspector to a running process securely; dump diagnostics reports when needed.

### Performance
Profile under load; use flame graphs; avoid blocking the event loop; cache I/O-bound results where appropriate.

---

## Test Runner (`node:test`)

**Example:**
```js
import { test } from 'node:test';
import assert from 'node:assert/strict';

test('adds', () => {
  assert.equal(1 + 2, 3);
});
```

Run with `node --test`. Supports parallel execution and coverage flags.

**Best Practices:**
- Use subtests and hooks when helpful.
- Collect coverage; keep tests deterministic.

---

# Appendix: Handy Snippets

**AbortController timeout for fetch**
```js
const controller = new AbortController();
const id = setTimeout(() => controller.abort(), 5000);
try {
  const res = await fetch(url, { signal: controller.signal });
  // ...
} finally {
  clearTimeout(id);
}
```

**Simple file server (streaming)**
```js
const http = require('node:http');
const fs = require('node:fs');
const path = require('node:path');

http.createServer((req, res) => {
  const filePath = path.join(__dirname, 'public', req.url === '/' ? 'index.html' : req.url);
  const stream = fs.createReadStream(filePath);
  stream.on('error', () => { res.statusCode = 404; res.end('Not Found'); });
  stream.pipe(res);
}).listen(3000);
```

**Worker Threads offload**
```js
const { Worker, isMainThread, parentPort, workerData } = require('node:worker_threads');
if (isMainThread) {
  const worker = new Worker(__filename, { workerData: 100000000 });
  worker.on('message', console.log);
} else {
  // heavy computation
  let sum = 0;
  for (let i = 0; i < workerData; i++) sum += i;
  parentPort.postMessage(sum);
}
```
