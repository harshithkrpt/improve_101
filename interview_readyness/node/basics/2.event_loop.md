# ğŸŒ Node.js Event Loop Explained

Node.js is **single-threaded** but uses **non-blocking I/O** via the **event loop**, which allows it to handle **thousands of concurrent operations** efficiently.

---

## ğŸ“Š Why Event Loop?

Traditional multi-threaded servers spawn a new thread per request (like in Java), but this leads to overhead. Node.js uses the **event loop** to avoid blocking operations, making it lightweight and scalable.

---

## ğŸ§  What Is the Event Loop?

The **event loop** is a mechanism that handles asynchronous operations. Node.js runs operations like file reads, HTTP requests, and timers asynchronously, and then pushes the callbacks into an internal queue.

---

## ğŸ§© Event Loop Phases

Below is the step-by-step breakdown of the event loop phases:

```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€>â”‚           timers          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚     pending callbacks     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚       idle, prepare       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   incoming:   â”‚
â”‚  â”‚           poll            â”‚<â”€â”€â”€â”€â”€â”¤  connections, â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚   data, etc.  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”‚           check           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”¤      close callbacks      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” Phase-by-Phase Breakdown

### 1. â±ï¸ Timers
Executes callbacks scheduled by:
```js
setTimeout()
setInterval()
```

**Example:**
```js
setTimeout(() => {
  console.log('Timer 1 finished');
}, 1000);
```

---

### 2. ğŸ•¹ï¸ Pending Callbacks
Executes I/O callbacks **deferred to the next loop**.

> Example: Some errors from TCP might show up here.

---

### 3. âš™ï¸ Idle, Prepare
Internal use. Node.js prepares for the next phase.

---

### 4. ğŸŒ€ Poll
- Waits for **I/O events** (e.g., file, network).
- Executes immediate I/O callbacks if available.
- If no timers are due and no callbacks to run, it will **wait** for incoming events.

**Example:**
```js
const fs = require('fs');
fs.readFile('file.txt', () => {
  console.log('File read complete');
});
```

---

### 5. âœ… Check
Executes callbacks from:
```js
setImmediate()
```

**Difference between `setTimeout` and `setImmediate`:**
- `setImmediate()` runs in **check phase**
- `setTimeout(fn, 0)` runs in **timers phase**

---

### 6. âŒ Close Callbacks
Handles close events like:
```js
socket.on('close', () => { ... });
```

---

## â›³ Microtasks Queue

### Runs **after each phase**, includes:
- `process.nextTick()`
- Promises `.then()`, `.catch()`, `.finally()`

**Example:**
```js
Promise.resolve().then(() => console.log('Promise'));
process.nextTick(() => console.log('Next Tick'));
```

**Order of execution:**
```
1. process.nextTick()
2. Promises
3. Event loop phases
```

---

## ğŸ“š Full Example: Understanding Execution Order

```js
console.log('Start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

setImmediate(() => {
  console.log('setImmediate');
});

Promise.resolve().then(() => {
  console.log('Promise');
});

process.nextTick(() => {
  console.log('nextTick');
});

console.log('End');
```

**Output:**
```
Start
End
nextTick
Promise
setTimeout
setImmediate
```

---

## ğŸ§µ Behind the Scenes

Node.js uses **libuv**:
- A C library that handles the event loop, I/O, and thread pool.
- Offloads heavy work (e.g., DNS, fs) to a thread pool and returns results asynchronously.

---

## ğŸ§  TL;DR Summary

| Phase             | Purpose                           |
|------------------|------------------------------------|
| Timers           | `setTimeout`, `setInterval`        |
| Pending Callbacks| Deferred I/O callbacks             |
| Idle, Prepare    | Internal                           |
| Poll             | Wait and execute I/O               |
| Check            | `setImmediate()`                   |
| Close Callbacks  | Handle closed connections          |

And between **every phase**, Node runs the **microtasks queue**:
- `process.nextTick()`
- Promises

---

## ğŸ› ï¸ Best Practices

- Use `setImmediate()` for **immediate but async execution**
- Use `process.nextTick()` sparingly â€” it can **starve** the event loop
- Prefer `async/await` (built on Promises) for clean async flow
- Donâ€™t block the event loop with long CPU tasks

---

## ğŸ”„ Comparison: Node.js vs Browser (UI) Event Loop

| Feature                | Node.js                         | Browser                          |
|------------------------|----------------------------------|-----------------------------------|
| Execution Context      | Backend, server-side            | Frontend, client-side            |
| Event Loop Engine      | `libuv`                         | Web APIs + event loop (HTML spec)|
| Microtasks             | `process.nextTick()`, Promises  | Promises, `MutationObserver`     |
| Macrotasks             | `setTimeout`, `setImmediate`    | `setTimeout`, `setInterval`      |
| Rendering Phase        | âŒ Not applicable                | âœ… Browser reflow/repaint        |
| I/O Handling           | Handled via `libuv`             | Handled via browser APIs         |
| Timer Accuracy         | High due to backend threading   | Lower, as browser throttles      |
| Threading              | Internal thread pool via libuv  | Web Workers (optional)           |

---

## âœ… Summary

- Nodeâ€™s event loop is optimized for **I/O-heavy** backend tasks.
- Browserâ€™s event loop is optimized for **UI responsiveness** and rendering.
- Both share the core concept of **event loop**, but differ in implementation and use-cases.

---