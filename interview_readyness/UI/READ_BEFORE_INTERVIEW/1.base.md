# Guide Before Interview Revision UI

- this document should & will act as a guide before going to any kind of ui interview.

## Publicis Sapient Inteview Questions (Learn From Failure):


### What is Critical CSS ? 

**Critical CSS** is the minimal set of CSS rules required to render the “above-the-fold” portion of a webpage—the content visible in the user’s viewport before they start scrolling. Inlining it can dramatically improve perceived load times and First Contentful Paint (FCP).

---

#### Why Critical CSS Matters

- **Reduced Render-Blocking**  
  Browsers block rendering while downloading and parsing external CSS. Inlining only the critical rules lets the page paint immediately, deferring the rest.

- **Faster First Paint**  
  Users see content sooner, improving perceived performance and engagement.

- **Better Core Web Vitals**  
  Reducing render-blocking resources can boost metrics like Largest Contentful Paint (LCP) and First Input Delay (FID).

---

#### How to Implement Critical CSS

1. **Identify Above-the-Fold Styles**  
   - Load your page in a desktop/mobile viewport (e.g., Chrome DevTools).  
   - Note which elements appear without scrolling, then determine which CSS rules they use.

2. **Extract Critical Rules**  
   - Manually copy the relevant CSS selectors and declarations.  
   - Or automate using tools (see below).

3. **Inline in `<head>`**  
```html
   <head>
     <!-- Critical CSS: inline for immediate rendering -->
     <style>
       /* e.g., body, header, nav, hero-section styles */
       body {
         margin: 0;
         font-family: sans-serif;
       }
       header {
         display: flex;
         /* … */
       }
       .hero {
         height: 60vh;
         background: url(hero.jpg) no-repeat center;
       }
       /* …other critical rules… */
     </style>

     <!-- Load the rest asynchronously -->
     <link
       rel="preload"
       href="main.css"
       as="style"
       onload="this.rel='stylesheet'"
     >
     <noscript>
       <link rel="stylesheet" href="main.css">
     </noscript>
   </head>
```


### What is the DOM Loading, CSS & JavaScript Execution: In-depth Theory ?

#### Table of Contents
1. [HTML Parsing & DOM Construction](#html-parsing--dom-construction)
2. [CSS Parsing & CSSOM Construction](#css-parsing--cssom-construction)
3. [JavaScript Engine & Execution Pipeline](#javascript-engine--execution-pipeline)
4. [Critical Rendering Path](#critical-rendering-path)
5. [Render Tree, Layout, & Paint](#render-tree-layout--paint)
6. [Render-Blocking Resources & Script Loading](#render-blocking-resources--script-loading)
7. [Event Loop, Tasks, & Microtasks](#event-loop-tasks--microtasks)
8. [DOMContentLoaded & Load Events](#domcontentloaded--load-events)
9. [Performance Optimizations](#performance-optimizations)
10. [Tools & Metrics](#tools--metrics)
11. [Impact of Frameworks (React, Vite, TypeScript)](#impact-of-frameworks-react-vite-typescript)
12. [Accessibility Considerations](#accessibility-considerations)
13. [Conclusion](#conclusion)

---

#### HTML Parsing & DOM Construction
- The browser fetches HTML bytes and feeds them to the HTML **tokenizer**, which splits into tokens (start tags, end tags, text, comments) according to the HTML5 parsing algorithm.
- Tokens are processed by the **tree constructor**, building a **DOM (Document Object Model)** tree using insertion modes (e.g., initial, before html, in head, in body).
- On encountering a `<script>` without `async`/`defer`, parsing pauses, the script is fetched and executed, then parsing resumes.
- Robust error-handling rules ensure that malformed HTML still produces a usable DOM tree.

#### CSS Parsing & CSSOM Construction
- Linked or inline CSS is fetched, then passed to the CSS **tokenizer** and **parser**, generating a **CSSOM (CSS Object Model)**.
- The CSS cascade resolves conflicts via **specificity**, **importance** (`!important`), **origin**, and **source order**.
- Media queries and `@import` rules may trigger additional fetches and re-parsing before finalizing the CSSOM.

#### JavaScript Engine & Execution Pipeline
- Modern engines (V8, SpiderMonkey) perform:
  1. **Parsing**: Source code → AST (Abstract Syntax Tree).
  2. **Bytecode Generation**: AST → interpreter-level bytecode.
  3. **Baseline JIT Compilation**: Hot code compiled to machine code.
  4. **Optimizing JIT**: Profiling-based optimizations; deoptimization on type changes.
  5. **Garbage Collection**: Incremental & generational GC to reclaim memory.
- JavaScript execution is **single-threaded**, using a **call stack**.

#### Critical Rendering Path
- Consists of **HTML**, **CSS**, **JavaScript**, **images**, and **fonts**. Each resource can block rendering.
- Key steps:
  1. **Build DOM** (HTML → DOM tree).
  2. **Build CSSOM** (CSS → CSSOM).
  3. **Create Render Tree** (DOM + CSSOM).
  4. **Layout** (compute geometry).
  5. **Paint** (draw pixels).
  6. **Composite** (GPU to combine layers).

#### Render Tree, Layout, & Paint
- **Render Tree** nodes represent visible elements; hidden elements (e.g., `display: none`) are omitted.
- **Layout** (reflow) computes size & position for each render-tree node.
- **Paint** fills pixels with content: text, colors, borders.
- GPUs handle **compositing** of layers for efficient redraws.

#### Render-Blocking Resources & Script Loading
- **CSS** is render-blocking by default: the browser must build the CSSOM before painting.
- **Scripts** without attributes block parsing and rendering:
  - **`defer`**: Download during parsing, execute after HTML parsing completes, before `DOMContentLoaded`.
  - **`async`**: Download in parallel, execute as soon as ready, pausing HTML parsing.
- **Resource Hints** (`preload`, `prefetch`, `preconnect`) can alter fetch priority.

#### Event Loop, Tasks, & Microtasks
- **Event Loop** phases: timers, pending callbacks, idle, poll, check, close callbacks.
- **Macrotasks**: callbacks from events, `setTimeout`, I/O operations.
- **Microtasks**: Promises, `MutationObserver`; executed at the end of each macrotask before rendering.
- Excessive reflows/repaints (style/layout thrashing) degrade UI performance.

#### DOMContentLoaded & Load Events
- **DOMContentLoaded** fires when the HTML is fully parsed and deferred scripts executed — CSSOM must be ready too.
- **Load** event fires when all resources (images, stylesheets, scripts) have finished loading.

#### Performance Optimizations
- **Minimize Critical Resources**: inline critical CSS, defer non-critical JS.
- Use **HTTP/2** or **HTTP/3** multiplexing to reduce connection overhead.
- **Code Splitting** & **Tree Shaking** (e.g., with Vite) to reduce JS payload.
- **Lazy Loading** images and modules.
- **Resource Hints**: `<link rel="preconnect">`, `dns-prefetch`.
- Break long tasks to maintain <50ms execution slices.

#### Tools & Metrics
- **Lighthouse** audits: FCP (First Contentful Paint), LCP (Largest Contentful Paint), TBT (Total Blocking Time), CLS (Cumulative Layout Shift).
- **DevTools**: Performance panel for flame charts, paint profiler, memory profiler.
- **Web Vitals** for real user monitoring.

#### Impact of Frameworks (React, Vite, TypeScript)
- **React**: Virtual DOM, reconciliation, SSR hydration. Initial JS bundle size critical for hydration time.
- **Vite**: Dev server using native ES modules, ultra-fast HMR. Production build uses Rollup for code splitting.
- **TypeScript**: Transpilation adds build step; ensure source maps for debugging. Proper TS config aids tree-shaking.

#### Accessibility Considerations
- Use semantic HTML for screen readers.
- Minimize layout shifts to preserve focus.
- Leverage ARIA roles/properties to expose dynamic content.
- Ensure critical functionality is not dependent solely on JS.

#### Conclusion
Understanding the **inner workings** of DOM parsing, CSSOM construction, JS execution, and the critical rendering path is essential for optimizing modern web applications. Leveraging tools like **Lighthouse**, bundlers like **Vite**, and frameworks like **React** enhances **UI performance**, accessibility, and maintainability.

---


# Event Delegation in JavaScript

## Table of Contents
1. [Introduction](#introduction)
2. [DOM Event Propagation](#dom-event-propagation)
   - [Capturing Phase](#capturing-phase)
   - [Target Phase](#target-phase)
   - [Bubbling Phase](#bubbling-phase)
3. [What is Event Delegation?](#what-is-event-delegation)
4. [Benefits of Event Delegation](#benefits-of-event-delegation)
5. [Implementing Event Delegation](#implementing-event-delegation)
   - [Vanilla JavaScript](#vanilla-javascript)
   - [TypeScript Example](#typescript-example)
6. [Using Event Delegation in React](#using-event-delegation-in-react)
7. [Accessibility Considerations](#accessibility-considerations)
8. [UI Performance Impact](#ui-performance-impact)
9. [Best Practices](#best-practices)
10. [Conclusion](#conclusion)

---

## Introduction
Event delegation is a pattern in **DOM** event handling where a single listener on a parent element handles events for multiple child elements, leveraging event **bubbling** to simplify code and improve performance.

## DOM Event Propagation
DOM events propagate in three phases:
1. **Capturing Phase**: Event travels from the root down to the target.
2. **Target Phase**: Event reaches the target element.
3. **Bubbling Phase**: Event bubbles up from the target back to the root.

### Capturing Phase
To listen during capturing, pass `true` or `{ capture: true }`:
```js
parent.addEventListener('click', handler, { capture: true });
```

### Target Phase
Handler invoked when the event is at the target.

### Bubbling Phase
Default phase for most events:
```js
parent.addEventListener('click', handler);
```

## What is Event Delegation?
Instead of attaching listeners to each child, attach one listener to a common ancestor:
```html
<ul id="menu">
  <li data-action="new">New</li>
  <li data-action="open">Open</li>
  <li data-action="save">Save</li>
</ul>
```
```js
const menu = document.getElementById('menu');
menu.addEventListener('click', (event) => {
  const item = event.target.closest('li');
  if (!item) return;
  console.log(item.dataset.action);
});
```

## Benefits of Event Delegation
- **Reduced Memory Footprint**: Fewer listeners attached.
- **Dynamic Elements**: Handles events on elements added later.
- **Simplified Management**: Centralized event logic.

## Implementing Event Delegation

### Vanilla JavaScript
```js
document.getElementById('list').addEventListener('click', (e) => {
  const target = e.target;
  if (target.matches('li')) {
    console.log('Clicked:', target.textContent);
  }
});
```

### TypeScript Example
```ts
const list = document.getElementById('list') as HTMLUListElement;
list.addEventListener('click', (e: MouseEvent) => {
  const target = e.target as HTMLElement;
  if (target && target.matches('li.item')) {
    const item = target as HTMLLIElement;
    console.log('Item ID:', item.id);
  }
});
```

## Using Event Delegation in React
React employs a **Synthetic Event** system on the `document`. For large lists, consider:
```jsx
function Menu({ items }) {
  const handleClick = (e) => {
    const item = e.target.closest('li');
    if (!item) return;
    console.log(item.dataset.action);
  };

  return (
    <ul onClick={handleClick}>
      {items.map(action => (
        <li key={action} data-action={action}>{action}</li>
      ))}
    </ul>
  );
}
```
Tools like **Vite** ensure fast HMR for development.

## Accessibility Considerations
- Ensure keyboard events (`keydown`, `keyup`) are handled.
- Use semantic HTML (`<button>` instead of clickable `<div>`).
- Manage focus states to maintain navigability.

## UI Performance Impact
Event delegation reduces JavaScript overhead and improves **UI performance** by:
- Lowering **Total Blocking Time** (TBT)
- Minimizing layout and paint triggers

## Best Practices
- Use `event.target.closest()` to guard against unintended targets.
- Clean up listeners if the parent is removed.
- Combine delegation with **debouncing** for high-frequency events (e.g., `scroll`).

## Conclusion
Event delegation leverages the DOM’s event **bubbling** to create efficient, maintainable event-driven interfaces. Mastering this concept boosts performance, reduces complexity, and scales gracefully with dynamic content.

---

# Event Propagation in the DOM

## Table of Contents
1. [Introduction](#introduction)
2. [Event Flow Phases](#event-flow-phases)
   - [Capturing Phase](#capturing-phase)
   - [Target Phase](#target-phase)
   - [Bubbling Phase](#bubbling-phase)
3. [Capturing vs Bubbling](#capturing-vs-bubbling)
4. [Attaching Listeners](#attaching-listeners)
5. [Stopping Propagation](#stopping-propagation)
6. [Examples](#examples)
   - [Vanilla JavaScript](#vanilla-javascript)
   - [HTML & Inline Listeners](#html--inline-listeners)
7. [Use Cases](#use-cases)
8. [Best Practices](#best-practices)
9. [Conclusion](#conclusion)

---

## Introduction
Event propagation describes how events travel through the DOM tree. Understanding propagation is key for managing complex event-driven UIs.

## Event Flow Phases
The DOM Level 3 Events specification defines three phases:

### Capturing Phase
The event starts at the **root** and travels **down** to the target element. Listeners registered with `capture: true` handle the event during this phase.

### Target Phase
The event reaches the **actual** target node. Listeners on the target fire here, regardless of capture settings.

### Bubbling Phase
After the target phase, the event **bubbles up** from the target back to the root. Listeners registered without capture handle the event here (default).

## Capturing vs Bubbling
| Aspect           | Capturing Phase (`capture: true`) | Bubbling Phase (`capture: false`) |
|------------------|-----------------------------------|-----------------------------------|
| Direction        | Top → Target                      | Target → Top                      |
| Default          | No                                | Yes                               |
| Event Order      | Fires before target listeners     | Fires after target listeners      |

## Attaching Listeners
```js
// Bubbling listener (default)
element.addEventListener('click', handler);

// Capturing listener
element.addEventListener('click', handler, { capture: true });
```

## Stopping Propagation
```js
function handler(event) {
  event.stopPropagation();           // Stops further propagation in current phase
  event.stopImmediatePropagation();  // Stops all other listeners on the same element
}
```

## Examples

### Vanilla JavaScript
```html
<div id="outer">
  <button id="inner">Click me</button>
</div>
<script>
  const outer = document.getElementById('outer');
  const inner = document.getElementById('inner');

  // Capturing
  outer.addEventListener('click', () => console.log('Outer Capturing'), { capture: true });

  // Target
  inner.addEventListener('click', () => console.log('Inner Target'));

  // Bubbling
  outer.addEventListener('click', () => console.log('Outer Bubbling'));
</script>
```
**Expected Console Order**:
1. Outer Capturing
2. Inner Target
3. Outer Bubbling

### HTML & Inline Listeners
```html
<div onclick="console.log('Outer Inline')" id="outer">
  <button id="inner" onclick="console.log('Inner Inline')">Click</button>
</div>
<script>
  const outer = document.getElementById('outer');
  // Default listeners here are in bubbling phase
  outer.addEventListener('click', () => console.log('Outer JS Listener'));
</script>
```

## Use Cases
- Implementing modular UI components without multiple listeners
- Conditional handling based on event origin
- Logging or analytics on container elements

## Best Practices
- Prefer **delegation** over many individual listeners where applicable
- Use `stopPropagation` sparingly to avoid unpredictable behavior
- Clearly document listener capture settings in team projects

## Conclusion
Mastering event propagation (capturing and bubbling) empowers you to craft efficient, maintainable, and predictable event-driven interfaces in modern web applications.

--- 

# DOM Manipulation: innerHTML & Alternatives

## 1. innerHTML

### Advantages
- **Simplicity**: Easy to use — assign or read `element.innerHTML` with an HTML string.
- **Bulk Updates**: Efficient for inserting or replacing large chunks of HTML at once.
- **Versatility**: Supports inserting mixed HTML elements and text in one operation.
- **Browser Optimization**: Modern engines optimize string parsing and insertion.

### Disadvantages
- **Security Risks**: Vulnerable to XSS if inserting untrusted content without sanitization.
- **Performance Overhead**: Re-parses and re-creates entire subtree, even for small changes.
- **Event Listener Loss**: Replacing content removes existing event listeners on child nodes.
- **No Incremental Updates**: Cannot modify individual nodes; must rewrite entire innerHTML.
- **Limited Control**: Harder to manage complex dynamic attributes or stateful components.

---

## 2. Alternatives to innerHTML

### 2.1 `createElement` & `appendChild`
```js
const div = document.createElement('div');
div.textContent = 'Hello';
parent.appendChild(div);
```
- **Advantages**: Fine-grained control, safe against XSS when using `textContent`, preserves existing nodes and listeners.
- **Disadvantages**: Verbose for many elements, can be slower for large batch operations.

### 2.2 `insertAdjacentHTML`
```js
element.insertAdjacentHTML('beforeend', '<p>New</p>');
```
- **Advantages**: Fast, does not remove existing listeners, fine-grained insertion (beforebegin, afterbegin, beforeend, afterend).
- **Disadvantages**: Still involves HTML parsing and XSS risk if unsanitized.

### 2.3 `textContent` / `innerText`
```js
element.textContent = 'Plain text';
```
- **Advantages**: Safe for text (no HTML parsing), prevents XSS.
- **Disadvantages**: Cannot insert HTML markup.

### 2.4 `DocumentFragment`
```js
const frag = document.createDocumentFragment();
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item;
  frag.appendChild(li);
});
ul.appendChild(frag);
```
- **Advantages**: Efficient batch insertion, minimizes reflows.
- **Disadvantages**: More boilerplate, initial creation cost.

### 2.5 `cloneNode`
```js
const clone = template.content.cloneNode(true);
parent.appendChild(clone);
```
- **Advantages**: Reuse existing template structure, preserves complex markup.
- **Disadvantages**: Must define `<template>`, deep clones include event handlers? (no, handlers are not cloned).

### 2.6 Framework & Library Methods
- **jQuery**: `$(selector).html()`, `append()`, `text()`.
- **React / Vue**: Virtual DOM diffing handles updates efficiently.
- **Advantages**: Declarative, state-driven, performant batch updates.
- **Disadvantages**: Learning curve, additional abstractions, larger bundle size.

---

## 3. Choosing the Right Method

| Method                 | Use Case                                 | Security   | Performance       | Complexity |
|------------------------|------------------------------------------|------------|-------------------|------------|
| `innerHTML`            | Large static HTML inserts                | Low (XSS)  | Medium–High       | Low        |
| `insertAdjacentHTML`   | Fine-grained HTML insertion             | Low (XSS)  | High              | Low        |
| `createElement`        | Dynamic element creation with events     | High       | Medium            | Medium     |
| `DocumentFragment`     | Batch DOM updates, lists rendering       | High       | High              | Medium     |
| `textContent`          | Plain text insertion                    | High       | High              | Low        |
| Frameworks (React/Vue) | Complex UI with state management        | High       | High (diffing)    | High       |

---

## 4. Best Practices
- **Sanitize** all HTML strings when using methods that parse HTML.
- **Prefer textContent** for plain text.
- Use **DocumentFragment** for large batch updates to minimize reflows.
- Leverage **framework diffing** for complex, state-driven UIs.
- Avoid frequent use of `innerHTML` in loops; batch updates instead.

---

# Disadvantages of Using Anonymous Functions in React JSX

## Table of Contents
1. [Introduction](#introduction)
2. [Frequent Re-Creation on Every Render](#frequent-re-creation-on-every-render)
3. [Reconciliation & Rendering Overhead](#reconciliation--rendering-overhead)
4. [Breaking PureComponent and React.memo](#breaking-purecomponent-and-reactmemo)
5. [Prop Reference Inequality](#prop-reference-inequality)
6. [Event Handler Cleanup](#event-handler-cleanup)
7. [Debugging and Profiling Challenges](#debugging-and-profiling-challenges)
8. [Best Practices & Alternatives](#best-practices--alternatives)
9. [Conclusion](#conclusion)

---

## Introduction
Using anonymous functions (inline arrow functions or function expressions) directly in JSX can lead to subtle performance and maintainability issues in React applications.

## Frequent Re-Creation on Every Render
Every render cycle recreates the anonymous function, resulting in a new function reference:
```jsx
<button onClick={() => doSomething(item.id)}>Click</button>
```
- **Impact**: Allocates memory for a new function on each render.

## Reconciliation & Rendering Overhead
- React’s reconciliation compares virtual DOM trees; new function references signal changed props.
- **Result**: Extra diffing work and potential re-rendering of child components, even if they don't depend on the function logic.

## Breaking PureComponent and React.memo
- **PureComponent** and **React.memo** do shallow prop comparisons. New inline functions break memoization:
```jsx
const Child = React.memo(({ onClick }) => { /* ... */ });
<Child onClick={() => handleClick()} />
```
- **Effect**: `Child` sees a new `onClick` each time and re-renders.

## Prop Reference Inequality
Passing inline functions as props causes referential inequality:
```jsx
<MyComponent onChange={(e) => setValue(e.target.value)} />
```
- Hard to optimize with `shouldComponentUpdate` or `memo`.

## Event Handler Cleanup
In class components or effect hooks, inline functions in event listeners can hinder proper cleanup:
```jsx
useEffect(() => {
  window.addEventListener('resize', () => handleResize());
  return () => {
    window.removeEventListener('resize', () => handleResize()); // different function reference
  };
}, []);
```
- **Issue**: `removeEventListener` does not remove the original listener.

## Debugging and Profiling Challenges
- Anonymous functions lack names in stack traces, making profiling and debugging harder.
- **Profilers**: show `<Anonymous>` or `<unknown>` entries for inline handlers.

## Best Practices & Alternatives
- **useCallback** hook:
  ```jsx
  const handleClick = useCallback(() => {
    doSomething(item.id);
  }, [item.id]);
  <button onClick={handleClick}>Click</button>
  ```
- **Class methods** for class components:
  ```jsx
  class MyComp extends React.Component {
    handleClick = () => { /* ... */ };
    render() {
      return <button onClick={this.handleClick}>Click</button>;
    }
  }
  ```
- **Named functions** defined outside render for functional components:
  ```jsx
  function MyComponent({ onAction }) {
    const handleAction = () => { /* ... */ };
    return <button onClick={handleAction}>Act</button>;
  }
  ```

## Conclusion
While inline anonymous functions in JSX offer convenience, they can introduce performance regressions and complicate optimizations. Prefer stable function references via `useCallback`, class methods, or named handlers to ensure predictable rendering and easier debugging.

# Render-Blocking Resources in the Browser

## Table of Contents
1. [Introduction](#introduction)
2. [Critical Rendering Path](#critical-rendering-path)
3. [Types of Render-Blocking Resources](#types-of-render-blocking-resources)
   - [CSS Stylesheets](#css-stylesheets)
   - [JavaScript Files](#javascript-files)
   - [Web Fonts](#web-fonts)
4. [How Render Blocking Works](#how-render-blocking-works)
5. [Performance Impact](#performance-impact)
6. [Detection & Metrics](#detection--metrics)
7. [Mitigation Strategies](#mitigation-strategies)
   - [Async & Defer for Scripts](#async--defer-for-scripts)
   - [Inlining Critical CSS](#inlining-critical-css)
   - [Resource Hints](#resource-hints)
   - [Preloading & Preconnecting](#preloading--preconnecting)
   - [Split and Lazy Load](#split-and-lazy-load)
8. [Best Practices](#best-practices)
9. [Conclusion](#conclusion)

---

## Introduction
Render-blocking resources are files that the browser must fetch, parse, or execute before it can render any content to the screen. These resources delay the First Contentful Paint (FCP) and Largest Contentful Paint (LCP).

## Critical Rendering Path
The critical rendering path comprises steps from HTML parsing to rendering pixels:
1. **DOM Construction** (HTML → DOM)
2. **CSSOM Construction** (CSS → CSSOM)
3. **Render Tree Creation** (DOM + CSSOM)
4. **Layout** (Reflow)
5. **Paint** (Rasterization)

Any resource required in these steps that isn’t already available causes blocking.

## Types of Render-Blocking Resources

### CSS Stylesheets
- External `<link rel="stylesheet">` blocks both DOM parsing and rendering until CSSOM is complete.
- CSS imports (`@import`) incur additional blocking fetches.

### JavaScript Files
- Synchronous `<script>` tags pause HTML parsing.  
- Scripts may also block CSSOM construction if loaded before styles.

### Web Fonts
- `@font-face` rules can block text rendering (Flash of Invisible Text, FOIT).

## How Render Blocking Works
1. **Encounter Resource**: Browser pauses DOM/CSSOM construction.
2. **Fetch**: Initiates HTTP request.
3. **Parse/Execute**: Parses CSS or executes JS.
4. **Resume**: Continues parsing and eventually renders.

## Performance Impact
- Increases **Time to First Byte (TTFB)** dependency on slow resources.
- Delays FCP and LCP, hurting user-perceived performance.
- Contributes to increased **Total Blocking Time (TBT)**.

## Detection & Metrics
- **Lighthouse**: Reports render-blocking resources and suggests optimizations.
- **WebPageTest**: Waterfall charts show blocking phases.
- **Performance API**: `performance.getEntriesByType('resource')`.

## Mitigation Strategies

### Async & Defer for Scripts
- `<script async>`: Downloads in parallel, executes immediately when ready—still blocks rendering during execution.
- `<script defer>`: Downloads in parallel, executes after parsing finishes, before `DOMContentLoaded`.

### Inlining Critical CSS
- Embed above-the-fold CSS in `<style>` tags in `<head>` to eliminate blocking fetch.
- Load remaining CSS asynchronously.

### Resource Hints
- `<link rel="preload" as="style">` or `as="script"` to prioritize fetch.
- `<link rel="prefetch">` for non-critical future resources.

### Preloading & Preconnecting
- `<link rel="preconnect" href="https://example.com">` to set up early connections.
- `<link rel="dns-prefetch" href="//fonts.googleapis.com">`.

### Split and Lazy Load
- Code-split JavaScript bundles.
- Lazy-load non-critical modules and images.

## Best Practices
- Audit third-party scripts; load only essential ones.
- Consolidate and minify CSS.
- Use HTTP/2 for multiplexed resource delivery.
- Monitor real-user metrics (RUM) to catch regression.

## Conclusion
Minimizing render-blocking resources is key to fast, responsive web applications. By understanding the critical rendering path and applying mitigation strategies, you can significantly improve user experience and performance metrics.

---

# Server-Side Rendering (SSR) & Static Site Generation (SSG)

## Table of Contents
1. [Introduction](#introduction)
2. [What is SSR?](#what-is-ssr)
   - [How SSR Works](#how-ssr-works)
   - [Advantages of SSR](#advantages-of-ssr)
   - [Disadvantages of SSR](#disadvantages-of-ssr)
3. [What is SSG?](#what-is-ssg)
   - [How SSG Works](#how-ssg-works)
   - [Advantages of SSG](#advantages-of-ssg)
   - [Disadvantages of SSG](#disadvantages-of-ssg)
4. [SSR vs SSG: Comparison](#ssr-vs-ssg-comparison)
5. [Use Cases](#use-cases)
6. [Implementations & Frameworks](#implementations--frameworks)
   - [Next.js](#nextjs)
   - [Gatsby](#gatsby)
   - [Nuxt.js](#nuxtjs)
7. [SEO & Performance Considerations](#seo--performance-considerations)
8. [Choosing Between SSR and SSG](#choosing-between-ssr-and-ssg)
9. [Conclusion](#conclusion)

---

## Introduction
Modern web applications require fast load times, SEO friendliness, and dynamic capabilities. Two popular rendering strategies are **Server-Side Rendering (SSR)** and **Static Site Generation (SSG)**.

## What is SSR?
SSR generates HTML on the server for each incoming request and sends it to the client.

### How SSR Works
1. Client requests a page URL.
2. Server fetches required data.
3. Server renders React/Vue templates into HTML.
4. Server sends fully rendered HTML to the browser.
5. Browser parses HTML and hydrates client-side JavaScript.

### Advantages of SSR
- **SEO & Crawlers**: Search engines see fully rendered HTML.
- **Faster First Paint**: Users see content quickly.
- **Dynamic Data**: Content can update per request.

### Disadvantages of SSR
- **Server Load**: Each request triggers a render.
- **Latency**: Potentially slower TTFB under high load.
- **Complex Caching**: Must manage caches to balance freshness and performance.

## What is SSG?
SSG generates HTML pages at build time, before any request.

### How SSG Works
1. At build time, generator fetches data.
2. Generates static HTML for each route.
3. Deploys static files to CDN.
4. Users request pre-built pages.

### Advantages of SSG
- **Performance**: Served from CDN — minimal latency.
- **Scalability**: No per-request rendering overhead.
- **Security**: Fewer attack surfaces (no server logic).

### Disadvantages of SSG
- **Build Time**: Longer builds for many pages.
- **Stale Content**: Updates require rebuilds or incremental regeneration.
- **Less Dynamic**: Not ideal for highly personalized content.

## SSR vs SSG: Comparison
| Aspect            | SSR                                  | SSG                                    |
|-------------------|--------------------------------------|----------------------------------------|
| Rendering         | On each request                      | At build time                          |
| Performance       | Good FCP, variable TTFB              | Excellent FCP & TTFB                   |
| Scalability       | Vertical scaling                     | Horizontal scaling via CDN            |
| Cache            | Complex cache strategies             | CDN caching out of the box             |
| Dynamic Content   | Ideal for per-request data           | Best for mostly static content         |

## Use Cases
- **SSR**: e-commerce with user-specific prices, dashboards, content-heavy apps.
- **SSG**: blogs, marketing sites, documentation, portfolios.

## Implementations & Frameworks

### Next.js
- `getServerSideProps` for SSR.
- `getStaticProps` & `getStaticPaths` for SSG.

### Gatsby
- GraphQL data layer, `gatsby-node.js` for build-time generation.

### Nuxt.js
- `asyncData` for SSR.
- `generate` command for static sites.

## SEO & Performance Considerations
- Use SSR/SSG for improved SEO compared to client-only rendering.
- Leverage incremental static regeneration (ISR) in Next.js for hybrid approaches.
- Measure with Lighthouse metrics: FCP, LCP, TBT.

## Choosing Between SSR and SSG
- Choose **SSR** when content changes per user or request.
- Choose **SSG** for mostly static pages with infrequent updates.
- Consider **Hybrid**: use SSG with on-demand revalidation or SSR for specific routes.

## Conclusion
SSR and SSG each offer unique trade-offs. Understanding both helps you architect performant, SEO-friendly, and scalable web applications tailored to your project needs.

---

# Redux Middleware & Their Types

## Table of Contents
1. [Introduction](#introduction)
2. [What is Redux Middleware?](#what-is-redux-middleware)
3. [Middleware API & Signature](#middleware-api--signature)
4. [Core Use Cases](#core-use-cases)
5. [Common Middleware Types](#common-middleware-types)
   - [1. Logger Middleware](#1-logger-middleware)
   - [2. Thunk Middleware](#2-thunk-middleware)
   - [3. Saga Middleware](#3-saga-middleware)
   - [4. Observable (Redux-Observable)](#4-observable-redux-observable)
   - [5. Promise Middleware](#5-promise-middleware)
   - [6. Router Middleware](#6-router-middleware)
   - [7. Custom Middleware](#7-custom-middleware)
6. [Applying Middleware](#applying-middleware)
7. [Combining & Composing Middleware](#combining--composing-middleware)
8. [Best Practices](#best-practices)
9. [Conclusion](#conclusion)

---

## Introduction
Redux middleware provides a powerful way to extend Redux by intercepting dispatched actions before they reach the reducer, enabling logging, async operations, crash reporting, and more.

## What is Redux Middleware?
Middleware is a function that wraps the store’s `dispatch` method. It sits between action dispatch and the moment it reaches reducers, allowing side effects or modifications.

## Middleware API & Signature
A Redux middleware follows this signature:
```js
const middleware = storeAPI => next => action => {
  // Pre-processing
  const result = next(action);
  // Post-processing
  return result;
};
```
- **storeAPI**: `{ dispatch, getState }`
- **next**: function to pass action to the next middleware or reducer
- **action**: the dispatched Redux action

## Core Use Cases
- **Logging**: Track actions and state changes
- **Asynchronous Actions**: Handle API calls, timeouts
- **Crash Reporting**: Catch and report errors
- **Action Transformations**: Normalize, filter, or modify actions
- **Routing Integration**: Sync navigation events

## Common Middleware Types

### 1. Logger Middleware
Logs actions and state changes.
```js
const logger = store => next => action => {
  console.group(action.type);
  console.info('Dispatching:', action);
  const result = next(action);
  console.log('Next State:', store.getState());
  console.groupEnd();
  return result;
};
```

### 2. Thunk Middleware
Allows dispatching functions (thunks) for async logic.
```js
function thunk({ dispatch, getState }) {
  return next => action =>
    typeof action === 'function'
      ? action(dispatch, getState)
      : next(action);
}
```
- Enables `dispatch(asyncActionCreator())`.

### 3. Saga Middleware
Uses generator functions to manage complex async flows.
```js
import createSagaMiddleware from 'redux-saga';
const sagaMiddleware = createSagaMiddleware();
```
- Run sagas: `sagaMiddleware.run(rootSaga)`.

### 4. Observable (Redux-Observable)
Leverages RxJS to handle streams of actions.
```js
import { createEpicMiddleware } from 'redux-observable';
const epicMiddleware = createEpicMiddleware(rootEpic);
```

### 5. Promise Middleware
Handles actions that return promises.
```js
const promiseMiddleware = ({ dispatch }) => next => action => {
  if (action.payload && typeof action.payload.then === 'function') {
    action.payload.then(
      result => dispatch({ ...action, payload: result }),
      error => dispatch({ ...action, error: true, payload: error })
    );
  } else {
    return next(action);
  }
};
```

### 6. Router Middleware
Syncs Redux with router history (e.g., connected-react-router).
```js
import { routerMiddleware } from 'connected-react-router';
const historyMiddleware = routerMiddleware(history);
```

### 7. Custom Middleware
Any bespoke logic (e.g., analytics tracking).
```js
const analyticsMiddleware = store => next => action => {
  if (action.type.startsWith('USER_')) {
    trackEvent(action);
  }
  return next(action);
};
```

## Applying Middleware
Use `applyMiddleware` from Redux.
```js
import { createStore, applyMiddleware } from 'redux';
const store = createStore(
  rootReducer,
  applyMiddleware(logger, thunk, sagaMiddleware)
);
```

## Combining & Composing Middleware
Middleware order matters:
1. **First** middleware intercepts actions earliest.
2. **Compose** using `applyMiddleware`.
```js
const enhancer = applyMiddleware(m1, m2, m3);
createStore(rootReducer, enhancer);
```

## Best Practices
- **Order Carefully**: Async middleware (thunk/saga) before logger if you want logging of resolved actions.
- **Keep Middleware Simple**: Single responsibility.
- **Handle Errors**: Catch exceptions to avoid blocking dispatch.
- **Test Middleware**: Mock `storeAPI` and `next` to unit-test.

## Conclusion
Redux middleware is essential for managing side effects and extending store behavior. Choosing the right type—thunk, saga, observables, or custom—depends on your app’s complexity and architecture.


# Redux vs Redux Toolkit

## Table of Contents
1. [Introduction](#introduction)
2. [Overview](#overview)
   - [Redux](#redux)
   - [Redux Toolkit](#redux-toolkit)
3. [Key Differences](#key-differences)
   - [Boilerplate & Setup](#boilerplate--setup)
   - [Store Configuration](#store-configuration)
   - [Reducers & Immutable Updates](#reducers--immutable-updates)
   - [Side Effects & Middleware](#side-effects--middleware)
   - [Built-in Utilities](#built-in-utilities)
   - [Opinionated Defaults](#opinionated-defaults)
4. [Code Examples](#code-examples)
   - [Traditional Redux Setup](#traditional-redux-setup)
   - [Redux Toolkit Setup](#redux-toolkit-setup)
5. [When to Use Which](#when-to-use-which)
6. [Conclusion](#conclusion)

---

## Introduction
Redux is a predictable state container for JavaScript apps. Redux Toolkit (RTK) is the official, opinionated, batteries-included toolset for efficient Redux development.

## Overview

### Redux
- **Library** for managing global state.
- Requires manual setup: store, reducers, action creators, middleware.
- Focuses on **explicitness** and **flexibility**.

### Redux Toolkit
- Built on top of Redux.
- Provides **simplified APIs** and **sensible defaults**.
- Includes utilities to reduce boilerplate and handle common patterns.

## Key Differences

### Boilerplate & Setup
- **Redux**: Many files and boilerplate (action types, creators, switch statements).
- **RTK**: Uses `createSlice` to define actions and reducers in one place.

### Store Configuration
- **Redux**: `createStore(rootReducer, applyMiddleware(...))`.
- **RTK**: `configureStore({ reducer, middleware, devTools })` with default middleware and DevTools enabled.

### Reducers & Immutable Updates
- **Redux**: Must manually enforce immutability (e.g., spread, `Object.assign`).
- **RTK**: Uses Immer under the hood, allowing "mutating" syntax.

### Side Effects & Middleware
- **Redux**: Manually add middleware like thunk or saga.
- **RTK**: Includes `redux-thunk` by default; easily add custom middleware.

### Built-in Utilities
- **RTK** provides:
  - `createSlice`
  - `createAsyncThunk`
  - `createEntityAdapter`
  - `createSelector` from Reselect

### Opinionated Defaults
- **RTK** enables DevTools, immutable checks, and serializable checks out of the box.
- Encourages best practices and consistent patterns.

## Code Examples

### Traditional Redux Setup
```js
// actions.js
export const increment = () => ({ type: 'counter/increment' });

// reducer.js
const initialState = { value: 0 };
export function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'counter/increment':
      return { ...state, value: state.value + 1 };
    default:
      return state;
  }
}

// store.js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import { counterReducer } from './reducer';
const store = createStore(
  counterReducer,
  applyMiddleware(thunk)
);
export default store;
```

### Redux Toolkit Setup
```js
// counterSlice.js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    }
  }
});

export const { increment } = counterSlice.actions;
export default counterSlice.reducer;

// store.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: { counter: counterReducer }
});

export default store;
```

## When to Use Which
- **Redux**: When you need maximum flexibility or existing Redux ecosystem tools (e.g., custom enhancers).
- **RTK**: For most new projects to accelerate development, reduce errors, and follow best practices.

## Conclusion
Redux Toolkit streamlines Redux development by reducing boilerplate, providing built-in utilities, and enforcing best practices, while Redux itself remains a flexible core library for state management.


---

# Redux vs React Context API

## Table of Contents
1. [Introduction](#introduction)
2. [What is Redux?](#what-is-redux)
3. [What is React Context API?](#what-is-react-context-api)
4. [Key Differences](#key-differences)
   - [Purpose & Use Case](#purpose--use-case)
   - [State Management Scope](#state-management-scope)
   - [Performance & Re-renders](#performance--re-renders)
   - [Boilerplate & Complexity](#boilerplate--complexity)
   - [Developer Experience](#developer-experience)
5. [Code Examples](#code-examples)
   - [Redux Example](#redux-example)
   - [Context API Example](#context-api-example)
6. [When to Choose Which](#when-to-choose-which)
7. [Conclusion](#conclusion)

---

## Introduction
Both Redux and the React Context API are tools for state management in React applications, but they solve different problems and have distinct trade-offs.

## What is Redux?
Redux is a standalone library for predictable global state management. It uses a strict unidirectional data flow with actions, reducers, and a single immutable store. Middleware enables side-effects and async logic.

## What is React Context API?
The React Context API is a built-in feature that allows passing data through the component tree without prop drilling. It is best suited for sharing simple or static data like themes or locale settings.

## Key Differences

### Purpose & Use Case
- **Redux**: Designed for complex state logic, cross-cutting concerns, and large applications.
- **Context API**: Ideal for passing down static or low-frequency-changing data.

### State Management Scope
- **Redux**: Centralized single store; state is global and predictable.
- **Context API**: Scoped to a provider; can create multiple contexts for different data.

### Performance & Re-renders
- **Redux**: Connects components and controls updates via `mapStateToProps` or selectors; optimized with `useSelector`.
- **Context API**: Any update to context value triggers re-render of all consuming components; may need memoization to avoid unnecessary re-renders.

### Boilerplate & Complexity
- **Redux**: Requires setup of store, actions, reducers, middleware; more boilerplate.
- **Context API**: Minimal setup: create context, provider, and consumer/hooks.

### Developer Experience
- **Redux**: Rich ecosystem (Redux DevTools, middleware, RTK); strong community patterns.
- **Context API**: Simpler API; no external dependencies; fewer abstractions.

## Code Examples

### Redux Example
```js
// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: {
    increment: state => state + 1
  }
});

export const { increment } = counterSlice.actions;
export const store = configureStore({ reducer: counterSlice.reducer });

// Usage in component
import { useSelector, useDispatch } from 'react-redux';
const count = useSelector(state => state);
const dispatch = useDispatch();
<button onClick={() => dispatch(increment())}>{count}</button>
```

### Context API Example
```js
// CounterContext.js
import React, { createContext, useContext, useState } from 'react';

const CounterContext = createContext();

export function CounterProvider({ children }) {
  const [count, setCount] = useState(0);
  const increment = () => setCount(c => c + 1);
  return (
    <CounterContext.Provider value={{ count, increment }}>
      {children}
    </CounterContext.Provider>
  );
}

export function useCounter() {
  return useContext(CounterContext);
}

// Usage in component
import { useCounter } from './CounterContext';
const { count, increment } = useCounter();
<button onClick={increment}>{count}</button>
```

## When to Choose Which
- **Use Redux** for large-scale apps with complex state interactions, middleware needs, and strict state predictability.
- **Use Context API** for simpler or UI-specific state (theme, locale, authentication flags) where boilerplate reduction is prioritized.

## Conclusion
Redux and the React Context API each have strengths: Redux excels in complex scenarios with rich tooling, while Context offers simplicity for lightweight state sharing. Choose based on application size, complexity, and performance requirements.

---

# Why We Use `useReducer` in React

## Table of Contents
1. [Introduction](#introduction)
2. [What is `useReducer`?](#what-is-usereducer)
3. [When to Use `useReducer` vs `useState`](#when-to-use-usereducer-vs-usestate)
4. [Advantages of `useReducer`](#advantages-of-usereducer)
5. [Disadvantages & Considerations](#disadvantages--considerations)
6. [Core Concepts](#core-concepts)
   - [Reducer Function](#reducer-function)
   - [Dispatch Function](#dispatch-function)
   - [Initial State](#initial-state)
7. [Usage Example](#usage-example)
8. [Common Use Cases](#common-use-cases)
9. [Best Practices](#best-practices)
10. [Conclusion](#conclusion)

---

## Introduction
The `useReducer` hook is an alternative to `useState` for managing complex state logic in React functional components. It is inspired by Redux and follows a reducer pattern.

## What is `useReducer`?
- A React hook that accepts a **reducer** function and an **initial state**, returning the current state and a **dispatch** method.
- Signature:
  ```ts
  const [state, dispatch] = useReducer(reducer, initialState, initArg?);
  ```

## When to Use `useReducer` vs `useState`
- **`useState`**: Best for simple, isolated state updates (primitive values, independent state slices).
- **`useReducer`**: Ideal for **complex state logic**, state transitions, or when the next state depends on the previous one.

## Advantages of `useReducer`
- **Predictable State Transitions**: Centralizes update logic in a single reducer.
- **Readability**: Action types and reducer make state updates explicit.
- **Testability**: Reducer functions can be tested independently.
- **Performance**: Can optimize with `useMemo` for dispatch and state selection.
- **Scalability**: Handles multiple related state values in one structure.

## Disadvantages & Considerations
- **Boilerplate**: Requires defining action types and reducer functions.
- **Verbosity**: More code compared to simple `useState`.
- **Learning Curve**: Pattern may be unfamiliar for beginners.

## Core Concepts

### Reducer Function
A pure function:
```ts
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    default:
      return state;
  }
}
```

### Dispatch Function
Used to send actions:
```ts
dispatch({ type: 'increment' });
```

### Initial State
Can be a value or an initializer function:
```ts
const initialState = { count: 0 };
// or
const init = () => ({ count: 0 });
```

## Usage Example
```jsx
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return initialState;
    default:
      throw new Error('Unknown action');
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
    </div>
  );
}
```

## Common Use Cases
- **Form Management**: Complex forms with multiple fields and validation.
- **State Machines**: Managing states with well-defined transitions.
- **Undo/Redo**: Storing previous states.
- **Global State**: Combined with `Context` for app-wide state.

## Best Practices
- **Define Action Types**: Use constants or enums for action type consistency.
- **Keep Reducers Pure**: Avoid side effects within reducers.
- **Split Reducers**: Combine multiple reducers for modular logic.
- **Use `useContext`**: Share reducer state across components when needed.

## Conclusion
`useReducer` enhances state management in React by providing a predictable, testable, and scalable approach for complex state logic. While it introduces some boilerplate, its benefits often outweigh the costs for medium to large applications.



## Debounce Code 

```js
  /**
 * Creates a debounced version of fn that delays invoking fn
 * until after wait milliseconds have elapsed since the last
 * time the debounced function was called.
 *
 * @param {Function} fn        The function to debounce.
 * @param {number}   wait      Delay in milliseconds.
 * @param {boolean}  immediate If true, trigger on the leading edge instead of the trailing.
 * @returns {Function}         The debounced function.
 */
function debounce(fn, wait = 250, immediate = false) {
  let timeoutId;

  return function debounced(...args) {
    const context = this;

    const later = () => {
      timeoutId = null;
      if (!immediate) {
        fn.apply(context, args);
      }
    };

    const callNow = immediate && !timeoutId;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(later, wait);

    if (callNow) {
      fn.apply(context, args);
    }
  };
}

// Usage example:
const onResize = () => {
  console.log('Window resized at', new Date().toLocaleTimeString());
};

window.addEventListener('resize', debounce(onResize, 300));

```


### Debounce and throttling are two techniques to control how often a function can fire in response to high-frequency events (like scrolling or typing).

- Debounce Delays invoking a function until a certain amount of “quiet” time has passed.
- Use case: Wait until the user stops typing to send an API request.

```js

function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Usage:
const onSearch = debounce(query => {
  console.log('Fetching for', query);
}, 300);

input.addEventListener('input', e => {
  onSearch(e.target.value);
});
```

- If the user keeps typing, the timer resets, so fn only runs 300 ms after the last keystroke.

### Throttling

- Ensures a function runs at most once every interval, no matter how many times the event fires.

- Use case: Limit scroll‐handler calls to once every 100 ms.

```js
function throttle(fn, interval) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= interval) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}

// Usage:
const onScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
}, 100);

window.addEventListener('scroll', onScroll);
```
- Even if the user scrolls continuously, the handler only runs once per 100 ms.

> Technique	Fires when…	Best for
> Debounce	…events have “quieted down” for delay	Search inputs, resize
> Throttle	…at most once per interval	Scroll, mouse‐move, clicks

---

# Microtasks vs Macrotasks: Multiple Code Examples

## Introduction
This document contains several JavaScript code snippets illustrating the order of execution between **macrotasks** (e.g., `setTimeout`) and **microtasks** (e.g., Promise callbacks). Note that the **executor** of `new Promise(...)` runs **synchronously**, while its `.then` handlers run as microtasks.

---

## Example 1: Basic Promise vs setTimeout

```js
console.log('start');

setTimeout(() => console.log('timeout1'), 0);

Promise.resolve().then(() => console.log('promise1'));

console.log('end');
```

**Expected Output**:
```
start
end
promise1
timeout1
```

**Explanation**:
1. Synchronous logs: `start`, then `end`.  
2. Microtask: Promise `.then` runs before next render phase.  
3. Macrotask: `setTimeout` callback runs last.

---

## Example 2: Promise Executor vs .then

```js
console.log('start');

new Promise((resolve) => {
  console.log('promise constructor');
  resolve();
}).then(() => console.log('promise then'));

setTimeout(() => console.log('timeout'), 0);

console.log('end');
```

**Expected Output**:
```
start
promise constructor
end
promise then
timeout
```

**Explanation**:
- Promise executor runs immediately (synchronous).  
- `.then` is queued as a microtask.  
- `setTimeout` callback is a macrotask.

---

## Example 3: Mixed Tasks and Nested Calls

```js
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => {
  console.log('3');
  setTimeout(() => console.log('4'), 0);
});

new Promise((resolve) => {
  console.log('5');
  resolve();
}).then(() => console.log('6'));

console.log('7');
```

**Expected Output**:
```
1
5
7
3
6
2
4
```

**Explanation**:
1. Sync: `1`, `5`, `7`.  
2. Microtasks in order: first the Promise.resolve `.then` logs `3` and schedules a macrotask for `4`; next the second Promise `.then` logs `6`.  
3. Macrotasks in order: `2` (first `setTimeout`), then `4`.

---

## Example 4: Microtask Inside a Macrotask

```js
setTimeout(() => {
  console.log('timeout callback');
  Promise.resolve().then(() => console.log('promise inside timeout'));
}, 0);

Promise.resolve().then(() => console.log('first promise'));
```

**Expected Output**:
```
first promise
timeout callback
promise inside timeout
```

**Explanation**:
- The initial Promise `.then` runs in the first microtask checkpoint.  
- After all microtasks, the macrotask `timeout callback` runs.  
- Inside that callback, a new microtask logs `promise inside timeout` before the next macrotask.

---

## Example 5: Executor Without Resolve

```js
console.log('A');

const p = new Promise((resolve, reject) => {
  console.log('B');
  // no resolve() or reject()
});

p.then(
  () => console.log('C'),
  (err) => console.log('D', err)
);

console.log('E');
```

**Expected Output**:
```
A
B
E
```

**Explanation**:
- Executor runs synchronously (`B`).  
- Neither `resolve` nor `reject` is called, so neither handler executes.

---

## Summary

| Task Type      | Example API                  | Execution Order                   |
|----------------|------------------------------|-----------------------------------|
| **Sync**       | `new Promise` executor, logs | Immediate                         |
| **Microtask**  | Promise `.then`, `queueMicrotask` | After current sync, before macrotasks |
| **Macrotask**  | `setTimeout`, `setInterval`  | After microtasks, on next tick    |

Understanding these orders helps avoid subtle bugs and write performant asynchronous code.


---

# Improving CSS Performance

## Table of Contents
1. [Introduction](#introduction)
2. [Reduce CSS File Size](#reduce-css-file-size)
3. [Load CSS Efficiently](#load-css-efficiently)
4. [Minimize CSS Complexity](#minimize-css-complexity)
5. [Optimize CSS Selectors](#optimize-css-selectors)
6. [Avoid Layout Thrashing](#avoid-layout-thrashing)
7. [Use Hardware Acceleration](#use-hardware-acceleration)
8. [Critical CSS and Splitting](#critical-css-and-splitting)
9. [Font Loading Strategies](#font-loading-strategies)
10. [CSS Containment](#css-containment)
11. [Tools & Metrics](#tools--metrics)
12. [Best Practices](#best-practices)
13. [Conclusion](#conclusion)

---

## Introduction
Optimizing CSS is crucial for fast rendering, reduced blocking time, and a smooth user experience. This guide covers techniques to enhance CSS performance in modern web applications.

## Reduce CSS File Size
- **Minification**: Remove whitespace, comments, and redundant code (e.g., using `cssnano`).
- **Remove Unused CSS**: Use tools like PurgeCSS or PurifyCSS to eliminate dead rules.
- **Modular CSS**: Break large stylesheets into component-specific files to load only what’s needed.

## Load CSS Efficiently
- **`media` attributes**: Load non-critical CSS for print or themes conditionally.
  ```html
  <link rel="stylesheet" href="print.css" media="print">
  ```
- **`preload`** critical styles:
  ```html
  <link rel="preload" as="style" href="critical.css" onload="this.rel='stylesheet'">
  ```
- **Avoid `@import`**: Use `<link>` elements to parallelize fetches.

## Minimize CSS Complexity
- **Simplify selectors**: Keep specificity low and avoid deep descendant selectors.
- **Use utility/atomic classes**: Limit the number of unique selectors and rules.
- **Limit CSS rules**: Combine similar rules using shorthand and grouping.

## Optimize CSS Selectors
- **Avoid universal (`*`) and tag selectors** in large documents.
- **Prefer class and ID selectors** for faster matching.
- **Avoid qualifying universal selectors** like `ul li a` unnecessarily.

## Avoid Layout Thrashing
- **Batch DOM reads/writes**: Use `requestAnimationFrame` for visual updates.
- **Avoid frequent style queries**: Cache layout values (e.g., `getBoundingClientRect()`).
- **Debounce resize/scroll handlers** to limit reflows.

## Use Hardware Acceleration
- **Promote layers** for animations:
  ```css
  .animated {
    transform: translateZ(0);
    will-change: transform;
  }
  ```
- **Prefer `transform` and `opacity`** for animations over properties like `width` or `top`.

## Critical CSS and Splitting
- **Inline critical above-the-fold CSS** to reduce render-blocking.
- **Split CSS** into critical and non-critical bundles (e.g., using webpack or Vite plugins).
- **Lazy load** secondary CSS for non-essential components.

## Font Loading Strategies
- **Preload fonts**:
  ```html
  <link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
  ```
- **Use `font-display: swap`** to avoid FOIT (Flash of Invisible Text):
  ```css
  @font-face {
    font-family: 'MyFont';
    src: url('myfont.woff2') format('woff2');
    font-display: swap;
  }
  ```

## CSS Containment
- **Use `contain`** property to isolate layout, style, and paint:
  ```css
  .component {
    contain: layout paint;
  }
  ```
- **Benefit**: Limits browser’s scope for layout and paint calculations.

## Tools & Metrics
- **Lighthouse**: Audits unused CSS and reports CSS size.
- **DevTools Coverage**: Identify unused rules.
- **CSS Stats**: Analyze selector complexity and stylesheet size.
- **WebPageTest**: View waterfall for CSS loading.

## Best Practices
- Keep styles scoped to components or modules.
- Use BEM or similar naming conventions for predictability.
- Regularly audit and prune unused styles.
- Leverage CSS variables for theming and reducing duplication.

## Conclusion
Effective CSS performance optimization reduces render-blocking time, lowers layout thrashing, and ensures smooth animations. Applying these strategies leads to faster, more responsive user interfaces.

---


# Interface vs Type Alias in TypeScript

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Syntax](#basic-syntax)
3. [Extending and Implementing](#extending-and-implementing)
4. [Declaration Merging](#declaration-merging)
5. [Union and Intersection Types](#union-and-intersection-types)
6. [Computed and Conditional Types](#computed-and-conditional-types)
7. [When to Use Which](#when-to-use-which)
8. [Examples](#examples)
9. [Best Practices](#best-practices)
10. [Conclusion](#conclusion)

---

## Introduction
TypeScript offers two primary ways to name object shapes and other type constructs: **interfaces** and **type aliases**. Though similar, they have key differences.

## Basic Syntax

### Interface
```ts
interface User {
  id: number;
  name: string;
  isAdmin?: boolean;
}
```

### Type Alias
```ts
type User = {
  id: number;
  name: string;
  isAdmin?: boolean;
};
```

Both can describe object shapes, but **type** is more general and can alias primitives, unions, tuples, etc.

## Extending and Implementing

### Interface Extension
```ts
interface Admin extends User {
  accessLevel: string;
}
```

### Type Intersection
```ts
type Admin = User & {
  accessLevel: string;
};
```

**Classes** can implement interfaces but **cannot** implement type aliases directly:
```ts
class Person implements User { /* ... */ } // OK
// class Person implements UserAlias {} // Error
```

## Declaration Merging
- **Interfaces** support declaration merging. Multiple declarations with the same name are merged.
  ```ts
  interface User { id: number; }
  interface User { name: string; }
  // Result: interface User { id: number; name: string; }
  ```
- **Type aliases** do **not** merge; redeclaration causes an error.

## Union and Intersection Types
- **Type aliases** can represent union or tuple types:
  ```ts
  type Pet = Dog | Cat;
  type Point = [number, number];
  ```
- **Interfaces** cannot directly define unions or tuples.

## Computed and Conditional Types
- **Type aliases** can use advanced type operators:
  ```ts
  type ReadOnly<T> = {
    readonly [K in keyof T]: T[K];
  };
  type NameOrId<T> = T extends { name: infer N } ? N : T extends { id: infer I } ? I : never;
  ```
- **Interfaces** cannot express conditional or mapped types.

## When to Use Which
| Scenario                                     | Use Interface            | Use Type Alias            |
|----------------------------------------------|--------------------------|---------------------------|
| Describing object shapes                     | ✅                        | ✅                         |
| Extensible via declaration merging           | ✅                        | ❌                         |
| Unions, tuples, primitives                   | ❌                        | ✅                         |
| Computed/mapped/conditional types            | ❌                        | ✅                         |
| Implementing with classes                    | ✅                        | ❌                         |

## Examples

### Interface Example
```ts
interface Point {
  x: number;
  y: number;
}
```

### Type Alias Example
```ts
type RequestStatus = 'pending' | 'success' | 'error';
```

## Best Practices
- Prefer **interfaces** for public API object shapes and class contracts.
- Use **type aliases** for unions, tuples, and advanced type manipulations.
- Avoid unnecessary merging: use interfaces when you need extension, else use type aliases.

## Conclusion
While interfaces and type aliases overlap in describing object shapes, each has unique capabilities. Choosing the appropriate one improves code clarity, maintainability, and leverages TypeScript’s powerful type system.

---

# Generics in TypeScript

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Generic Syntax](#basic-generic-syntax)
3. [Generic Functions](#generic-functions)
4. [Generic Interfaces](#generic-interfaces)
5. [Generic Classes](#generic-classes)
6. [Generic Constraints](#generic-constraints)
7. [Default Generic Types](#default-generic-types)
8. [Utility Types with Generics](#utility-types-with-generics)
9. [Advanced Generic Patterns](#advanced-generic-patterns)
10. [Best Practices](#best-practices)
11. [Conclusion](#conclusion)

---

## Introduction
Generics provide a way to create reusable components that work with various data types. They enable writing flexible, type-safe code by introducing type parameters.

## Basic Generic Syntax
```ts
function identity<T>(value: T): T {
  return value;
}
```
- `<T>` declares a type parameter.
- `T` acts as a placeholder for the actual type.

## Generic Functions
```ts
// Working with arrays
function getFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

const num = getFirstElement<number>([1, 2, 3]); // num: number
const str = getFirstElement<string>(['a', 'b']); // str: string
```
- Type argument inference simplifies usage:
  ```ts
  const inferred = getFirstElement([true, false]); // inferred: boolean
  ```

## Generic Interfaces
```ts
interface Pair<T, U> {
  first: T;
  second: U;
}

const pair: Pair<string, number> = {
  first: 'hello',
  second: 42,
};
```

## Generic Classes
```ts
class Box<T> {
  constructor(public value: T) {}
  getValue(): T {
    return this.value;
  }
}

const box = new Box<Date>(new Date());
console.log(box.getValue());
```

## Generic Constraints
Restrict generics using `extends`:
```ts
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

logLength('hello');       // OK, string has length
logLength([1, 2, 3]);     // OK, array has length
// logLength(123);        // Error: number does not have 'length'
```

## Default Generic Types
Provide defaults for type parameters:
```ts
function createArray<T = string>(length: number, value: T): T[] {
  return Array.from({ length }, () => value);
}

const strings = createArray(3, 'a'); // string[]
const nums = createArray<number>(3, 0); // number[]
```

## Utility Types with Generics
Built-in conditional and mapped types use generics heavily:
- **`Partial<T>`**: all properties optional.
- **`Readonly<T>`**: all properties readonly.
- **`Pick<T, K>`**: select subset of properties.
- **`Record<K, T>`**: map keys `K` to type `T`.

```ts
interface User { name: string; age: number; }
type PartialUser = Partial<User>; // { name?: string; age?: number }
type NameAge = Pick<User, 'name' | 'age'>; // { name: string; age: number }
```

## Advanced Generic Patterns
- **Generic Constraints with `keyof`**:
  ```ts
  function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
  }
  ```
- **Generic Factory Functions**:
  ```ts
  function createInstance<T>(c: new () => T): T {
    return new c();
  }
  ```
- **Variadic Tuple Types** (TypeScript 4+):
  ```ts
  function tuple<T extends unknown[]>(...args: T): T {
    return args;
  }
  const t = tuple(1, 'a', true); // [number, string, boolean]
  ```

## Best Practices
- Name type parameters clearly (`T`, `U`, `K` for keys).
- Use constraints to enforce required properties.
- Leverage inference where possible to reduce boilerplate.
- Keep generics simple; avoid over-complex patterns unless necessary.

## Conclusion
Generics in TypeScript enable writing flexible, reusable, and type-safe components. Understanding and applying generic patterns leads to more robust codebases and better developer experience.


---

# Controlled vs Uncontrolled Components in React

## Table of Contents
1. [Introduction](#introduction)
2. [Controlled Components](#controlled-components)
   - [Definition](#definition)
   - [How They Work](#how-they-work)
   - [Example](#example)
   - [Advantages](#advantages)
   - [Disadvantages](#disadvantages)
3. [Uncontrolled Components](#uncontrolled-components)
   - [Definition](#definition-1)
   - [How They Work](#how-they-work-1)
   - [Example](#example-1)
   - [Advantages](#advantages-1)
   - [Disadvantages](#disadvantages-1)
4. [Differences at a Glance](#differences-at-a-glance)
5. [When to Use Which](#when-to-use-which)
6. [Best Practices](#best-practices)
7. [Conclusion](#conclusion)

---

## Introduction
In React, form inputs and other data-driven components can be managed in two primary ways: **controlled** and **uncontrolled**. Choosing the right approach impacts state management, validation, and integration with React’s data flow.

## Controlled Components

### Definition
Controlled components have their **value** controlled by React state. The source of truth is React, not the DOM.

### How They Work
- The component's state stores the input value.
- On each change, an event handler updates the state.
- The input’s `value` prop is set to the state variable.

### Example
```jsx
import React, { useState } from 'react';

function ControlledInput() {
  const [text, setText] = useState('');

  const handleChange = (e) => {
    setText(e.target.value);
  };

  return (
    <div>
      <input
        type="text"
        value={text}
        onChange={handleChange}
        placeholder="Type here..."
      />
      <p>Current value: {text}</p>
    </div>
  );
}
```

### Advantages
- **Single Source of Truth**: State managed by React.
- **Instant Validation**: Validate on each change.
- **Easy to Debug**: State updates are explicit.
- **Integration**: Works seamlessly with Redux or other state managers.

### Disadvantages
- **Verbose Boilerplate**: Requires state and handlers.
- **Performance**: Frequent re-renders on each keystroke may impact large forms.

## Uncontrolled Components

### Definition
Uncontrolled components manage their own state internally using the DOM. React reads values via refs.

### How They Work
- The component uses a `ref` to access the DOM node.
- Value is read when needed (e.g., on form submit).

### Example
```jsx
import React, { useRef } from 'react';

function UncontrolledInput() {
  const inputRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    alert('Input value: ' + inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        ref={inputRef}
        placeholder="Type here..."
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Advantages
- **Less Code**: No state hooks for each input.
- **Performance**: Less frequent re-renders.
- **Suitable for Simple Forms**: Quick prototypes or simple use cases.

### Disadvantages
- **Imperative Access**: Using refs is less declarative.
- **Validation Complexity**: Harder to validate on every change.
- **Debugging**: State isn't in React, making debugging harder.

## Differences at a Glance
| Aspect               | Controlled                       | Uncontrolled                    |
|----------------------|----------------------------------|---------------------------------|
| Data Source          | React state                      | DOM                              |
| Value Prop & Handler | `value` + `onChange`             | `defaultValue` + `ref`           |
| Rerenders            | On every change                  | Only when accessed via ref       |
| Validation           | Easy, inline                     | Extra code to read & validate    |
| Boilerplate          | More                             | Less                             |

## When to Use Which
- **Controlled**: Complex forms, instant validation, dynamic inputs, integration with global state.
- **Uncontrolled**: Simple forms, file inputs, third-party libraries, performance-critical scenarios.

## Best Practices
- For forms with many fields or dynamic requirements, prefer controlled components.
- Use uncontrolled components for simple, less interactive inputs or where React state overhead is unnecessary.
- Combine both approaches in complex forms where some fields are controlled and others are not.

## Conclusion
Controlled and uncontrolled components offer flexible approaches to form and input management in React. Understanding their trade-offs ensures you pick the right tool for your use case.


---

# Registering Form Fields with the `name` Attribute

## Introduction
In HTML forms, the **`name`** attribute is the key identifier for form controls. It determines which data is sent to the server when a form is submitted or how libraries/frameworks reference the field.

## Why the `name` Attribute Matters
- **Form Submission**: Browser collects values of inputs with a `name` and sends them as key-value pairs.
- **Server-Side Handling**: Backend frameworks (e.g., Express, Django) use `name` to parse and map incoming form data.
- **Client-Side Libraries**: Form libraries (e.g., React Hook Form, Formik) use `name` to register and manage form state.
- **Accessibility**: When paired with `<label for>`, `name` helps assistive technologies relate labels to inputs.

## Usage

```html
<form action="/submit" method="post">
  <label for="email">Email:</label>
  <input type="email" id="email" name="email" required>

  <label for="password">Password:</label>
  <input type="password" id="password" name="password" required>

  <button type="submit">Login</button>
</form>
```

On submission, the payload might look like:
```
email=user@example.com&password=secret
```

## Examples in JavaScript

### Vanilla JavaScript
```js
const form = document.querySelector('form');
form.addEventListener('submit', (e) => {
  e.preventDefault();
  const data = new FormData(form);
  console.log(data.get('email'));    // Accesses the input by name
  console.log(data.get('password'));
});
```

### React Hook Form
```jsx
import { useForm } from 'react-hook-form';

function LoginForm() {
  const { register, handleSubmit } = useForm();
  const onSubmit = data => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} placeholder="Email" />
      <input {...register('password')} type="password" placeholder="Password" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

## Best Practices
- Ensure each form control has a unique `name` within the form.
- Use meaningful, consistent naming conventions (e.g., snake_case or camelCase).
- Combine with `id` and `<label for>` for accessibility.

## Conclusion
The `name` attribute is essential for registering and identifying form fields both on the client and server. It underpins form submission, state management, and accessibility.  


---

# CSS Media Queries

## Table of Contents
1. [Introduction](#introduction)
2. [Syntax](#syntax)
3. [Media Features](#media-features)
4. [Types of Media Queries](#types-of-media-queries)
   - [Width/Height](#widthheight)
   - [Orientation](#orientation)
   - [Resolution](#resolution)
   - [Pointer & Hover](#pointer--hover)
5. [Logical Operators](#logical-operators)
   - [and](#and)
   - [or (comma)](#or-comma)
   - [not](#not)
6. [Responsive Design Strategies](#responsive-design-strategies)
   - [Mobile-First Approach](#mobile-first-approach)
   - [Desktop-First Approach](#desktop-first-approach)
7. [Common Breakpoints](#common-breakpoints)
8. [Examples](#examples)
   - [Basic Media Query](#basic-media-query)
   - [Orientation Example](#orientation-example)
   - [High-Resolution (Retina) Example](#high-resolution-retina-example)
9. [Best Practices](#best-practices)
10. [Testing & Debugging](#testing--debugging)
11. [Conclusion](#conclusion)

---

## Introduction
Media queries allow CSS to apply styles conditionally based on characteristics of the device or viewport, enabling responsive design.

## Syntax
```css
@media <media-query-list> {
  /* CSS rules */
}
```
- `<media-query-list>` can combine multiple queries separated by commas.

## Media Features
- **width**, **height**: viewport dimensions
- **orientation**: `portrait` or `landscape`
- **resolution**: device DPI or DPCM
- **aspect-ratio**: width-to-height ratio
- **pointer**: input mechanism accuracy (`none`, `coarse`, `fine`)
- **hover**: ability to hover (`hover`, `none`)

## Types of Media Queries

### Width/Height
```css
@media (max-width: 600px) { /* ≤ 600px */ }
@media (min-width: 601px) { /* ≥ 601px */ }
```

### Orientation
```css
@media (orientation: landscape) { /* wide viewports */ }
```

### Resolution
```css
@media (min-resolution: 2dppx) { /* retina displays */ }
```

### Pointer & Hover
```css
@media (pointer: coarse) { /* touch screens */ }
@media (hover: hover) { /* supports hover */ }
```

## Logical Operators

### and
Combine multiple features:
```css
@media (min-width: 768px) and (orientation: landscape) { }
```

### or (comma)
Comma acts as OR:
```css
@media (max-width: 600px), (orientation: portrait) { }
```

### not
Negation:
```css
@media not all and (monochrome) { /* color screens */ }
```

## Responsive Design Strategies

### Mobile-First Approach
- Write base styles for mobile.
- Add media queries with `min-width` to enhance for larger viewports.

### Desktop-First Approach
- Write base styles for desktop.
- Add media queries with `max-width` to adjust for smaller screens.

## Common Breakpoints
- **320px** (small mobile)
- **480px** (mobile)
- **768px** (tablet)
- **1024px** (small desktop)
- **1200px** (large desktop)

## Examples

### Basic Media Query
```css
body {
  font-size: 16px;
}

@media (max-width: 600px) {
  body {
    font-size: 14px;
  }
}
```

### Orientation Example
```css
@media (orientation: landscape) {
  .gallery {
    grid-template-columns: repeat(4, 1fr);
  }
}
```

### High-Resolution (Retina) Example
```css
@media (min-resolution: 2dppx) {
  .logo {
    background-image: url('logo@2x.png');
  }
}
```

## Best Practices
- Use **mobile-first** to reduce complexity.
- Keep breakpoints consistent across components.
- Avoid too many breakpoints; use fluid layouts when possible.
- Combine related rules in a single media query block.

## Testing & Debugging
- Use browser DevTools responsive mode.
- Test on real devices and emulators.
- Leverage CSS linting tools (e.g., stylelint) to enforce conventions.

## Conclusion
Media queries are fundamental for responsive web design, allowing CSS to adapt layouts and styles based on device capabilities and viewport dimensions. Proper use of media features and strategies ensures a seamless experience across devices.

---

# CSS-in-JS & Styled-Components Performance

## Table of Contents
1. [Introduction](#introduction)
2. [What is CSS-in-JS?](#what-is-css-in-js)
3. [Benefits of CSS-in-JS](#benefits-of-css-in-js)
4. [Drawbacks of CSS-in-JS](#drawbacks-of-css-in-js)
5. [Styled-Components Overview](#styled-components-overview)
6. [Performance Impacts of Styled-Components](#performance-impacts-of-styled-components)
   - [Runtime Overhead](#runtime-overhead)
   - [Bundle Size](#bundle-size)
   - [Style Duplication & Caching](#style-duplication--caching)
   - [Server-Side Rendering](#server-side-rendering)
   - [Critical CSS](#critical-css)
7. [Optimizations & Best Practices](#optimizations--best-practices)
8. [Conclusion](#conclusion)

---

## Introduction
CSS-in-JS refers to a pattern where CSS is composed using JavaScript, often co-located with components. Styled-Components is a popular library implementing this paradigm using tagged template literals.

## What is CSS-in-JS?
- Embeds styles directly within JavaScript modules.
- Generates unique class names at build or runtime.
- Supports dynamic styling based on props and theme.
- Examples: Styled-Components, Emotion, JSS, Stitches.

## Benefits of CSS-in-JS
- **Scoped Styles**: Avoids global CSS conflicts with automatic class generation.
- **Dynamic Styling**: Styles can respond to component props and state.
- **Theming**: Centralized theme objects ensure consistent design tokens.
- **Developer Experience**: Co-located styles improve maintainability and readability.
- **Dead Code Elimination**: Unused component styles can be tree-shaken in some setups.

## Drawbacks of CSS-in-JS
- **Runtime Style Generation**: Some libraries generate CSS at runtime, adding overhead.
- **Tooling Complexity**: Requires Babel/webpack plugins or runtime libraries.
- **Familiarity**: Developers need to learn library-specific APIs.
- **Performance**: Potential for increased rendering work and bundle size.

## Styled-Components Overview
- Uses tagged template literals: `const Button = styled.button\`...\`;`
- Generates unique class names and injects CSS into a `<style>` tag at runtime.
- Supports theming, global styles, and server-side rendering (SSR).
- CSS is only generated when components render.

## Performance Impacts of Styled-Components

### Runtime Overhead
- **Style Injection**: On first render, styled-components parses templates and injects CSS.
- **Reconciliation**: Generating and comparing class names adds JS work on render.

### Bundle Size
- Adds library size (~30KB gzip). Can impact initial load if not code-split.

### Style Duplication & Caching
- By default, styles for identical styled components are deduplicated.
- Dynamic styles per prop can lead to new unique classes and more CSS rules.

### Server-Side Rendering
- SSR support extracts and inlines critical styles but adds build complexity.
- Hydration mismatch risk if class generation order differs between server/client.

### Critical CSS
- Styles injected at runtime may delay CSS availability, impacting First Paint.
- Styled-components offers `StyleSheetManager` and `createGlobalStyle` to inline critical styles.

## Optimizations & Best Practices
- **Prefer Static Styles**: Extract static CSS to external files when possible.
- **Use Babel Plugin**: `babel-plugin-styled-components` enables better SSR, display names, and minification.
- **Limit Dynamic Styles**: Use props sparingly to avoid generating excessive class names.
- **Minimize Component Creation**: Avoid defining styled components inside render loops.
- **Leverage Server-Side CSS Extraction**: Inline critical CSS during SSR to reduce FOUC.
- **Code Splitting**: Load styled-components library only where needed.

## Conclusion
CSS-in-JS, particularly styled-components, offers powerful styling capabilities but introduces runtime and bundle overhead. By following best practices—such as static styles extraction, limiting dynamic props, and using SSR optimizations—you can harness its benefits while mitigating performance drawbacks.


---

# Incremental Static Regeneration (ISR)

## Table of Contents
1. [Introduction](#introduction)
2. [What is ISR?](#what-is-isr)
3. [How ISR Works](#how-isr-works)
   - [Revalidation](#revalidation)
   - [Fallback Modes](#fallback-modes)
4. [Code Example (Next.js)](#code-example-nextjs)
5. [Benefits of ISR](#benefits-of-isr)
6. [Drawbacks & Considerations](#drawbacks--considerations)
7. [Comparison: SSR, SSG, and ISR](#comparison-ssr-ssg-and-isr)
8. [Use Cases](#use-cases)
9. [Best Practices](#best-practices)
10. [Conclusion](#conclusion)

---

## Introduction
Incremental Static Regeneration (ISR) lets you create or update static pages **after** you’ve built your site. It combines the performance of Static Site Generation with the flexibility of dynamic content updates.

## What is ISR?
- A Next.js feature introduced in v9.5.
- Allows static pages to be regenerated on-demand or after a specified interval.
- Lets you serve stale pages while regenerating in the background.

## How ISR Works

### Revalidation
- You specify a `revalidate` interval (in seconds) in `getStaticProps`.
- On first request, page is statically generated and cached.
- Subsequent requests after the interval trigger regeneration in the background.
- Old page remains live until the new one is generated.

### Fallback Modes
- **`fallback: false`**: Only paths returned by `getStaticPaths` are generated; others return 404.
- **`fallback: true`**: New paths render a skeleton on first request, then generate and cache.
- **`fallback: 'blocking'`**: First request waits for generation then serves the page.

## Code Example (Next.js)
```js
// pages/posts/[id].js
export async function getStaticPaths() {
  return {
    paths: [{ params: { id: '1' } }],
    fallback: 'blocking', // or true/false
  };
}

export async function getStaticProps({ params }) {
  const post = await fetchPostById(params.id);
  return {
    props: { post },
    revalidate: 60, // Regenerate at most once every 60 seconds
  };
}

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}
```

## Benefits of ISR
- **Performance**: Static pages served from CDN.
- **Freshness**: Pages update without full rebuilds.
- **Scalability**: Regeneration happens on-demand.
- **UX**: No stale data after initial interval; seamless updates.

## Drawbacks & Considerations
- **Consistency**: Users may see stale data until regeneration.
- **Build Complexity**: Needs proper cache and fallback handling.
- **Server Load**: Regeneration incurs compute on first request after interval.
- **Limits**: Vercel imposes rate limits on ISR regenerations.

## Comparison: SSR, SSG, and ISR
| Strategy | Timing                           | Performance    | Freshness         | Use Case                          |
|----------|----------------------------------|----------------|-------------------|-----------------------------------|
| SSG      | Build time                       | Very High      | Static until rebuild | Blogs, docs, marketing sites |
| SSR      | On each request                  | Moderate       | Always fresh      | User dashboards, auth-based pages |
| ISR      | Build + On-demand after interval | High           | Near real-time    | News sites, e-commerce product pages |

## Use Cases
- **E-commerce**: Product pages update with inventory/prices.
- **News Sites**: Articles regenerate as edited.
- **Documentation**: Frequent updates without full rebuild.
- **Blogs**: New posts appear without redeploy.

## Best Practices
- Choose appropriate `revalidate` interval based on update frequency.
- Use `'blocking'` fallback for SEO-critical pages.
- Monitor regeneration latency and errors.
- Combine with On-Demand ISR (`res.unstable_revalidate`) for manual triggers.

## Conclusion
Incremental Static Regeneration bridges the gap between static and dynamic content, offering fast loads and timely updates. Used correctly, it provides an optimal balance for modern web applications.


---

# SOLID Principles & UI Design Patterns

## Table of Contents
1. [SOLID Principles in UI Development](#solid-principles-in-ui-development)
   - [Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)
   - [Open/Closed Principle (OCP)](#openclosed-principle-ocp)
   - [Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)
   - [Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)
   - [Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)
2. [Common UI Design Patterns](#common-ui-design-patterns)
   - [Container & Presentational Components](#container--presentational-components)
   - [Compound Components](#compound-components)
   - [Render Props](#render-props)
   - [Higher-Order Components (HOC)](#higher-order-components-hoc)
   - [Custom Hooks](#custom-hooks)
   - [Context Provider Pattern](#context-provider-pattern)
3. [Structural & Behavioral Patterns](#structural--behavioral-patterns)
   - [Observer (Pub/Sub)](#observer-pubsub)
   - [Singleton](#singleton)
   - [Factory](#factory)
   - [Strategy](#strategy)
4. [Component Composition Patterns](#component-composition-patterns)
   - [Atomic Design](#atomic-design)
   - [Controlled vs Uncontrolled](#controlled-vs-uncontrolled)
5. [UI Architectural Patterns](#ui-architectural-patterns)
   - [MVC / MVVM](#mvc--mvvm)
6. [Best Practices](#best-practices)
7. [Conclusion](#conclusion)

---

## SOLID Principles in UI Development

### Single Responsibility Principle (SRP)
A component or module should have **one reason to change**.
```jsx
// Bad: Button handles data fetch and UI
function SubmitButton() {
  const [data, setData] = useState(null);
  useEffect(() => { fetchData().then(setData) }, []);
  return <button>{data ? 'Loaded' : 'Loading...'}</button>;
}
// Good: Separate fetch logic from UI
function useData() { /* custom hook */ }
function SubmitButton() {
  const data = useData();
  return <button>{data ? 'Loaded' : 'Loading...'}</button>;
}
```

### Open/Closed Principle (OCP)
**Open for extension**, **closed for modification**.
- Extend component behavior via **props**, **composition**, or **slots** without altering existing code.
```jsx
function Card({ renderHeader, children }) {
  return <div>{renderHeader()}<div>{children}</div></div>;
}
// Extend header without modifying Card
<Card renderHeader={() => <h1>Title</h1>}>...</Card>
```

### Liskov Substitution Principle (LSP)
Subtypes must be substitutable for their base types.
```jsx
// Base button
function Button({ onClick, children }) { return <button onClick={onClick}>{children}</button>; }
// Specialized button
function IconButton(props) { return <Button {...props}><Icon />{props.children}</Button>; }
// IconButton can replace Button without breaking UI
```

### Interface Segregation Principle (ISP)
Favor **small, specific** interfaces over large, general ones.
- Provide specialized hooks or context slices.
```ts
// Instead of one large context
interface AppContext { user: User; theme: Theme; settings: Settings; }
// Create separate contexts
const UserContext = createContext<User>(...);
const ThemeContext = createContext<Theme>(...);
```

### Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules; both depend on **abstractions**.
```ts
// Abstraction for data service
interface IDataService { fetch(): Promise<Data>; }
// Implementation
class ApiService implements IDataService { fetch() { /* real fetch */ } }
// Component depends on IDataService
function DataViewer({ service }: { service: IDataService }) { /* ... */ }
```

---

## Common UI Design Patterns

### Container & Presentational Components
Separation of **data-fetching** logic (container) from **UI** (presentational).
```jsx
// Container
function UserListContainer() {
  const users = useUsers();
  return <UserList users={users} />;
}
// Presentational
function UserList({ users }) { return <ul>{users.map(u=> <li key={u.id}>{u.name}</li>)}</ul>; }
```

### Compound Components
Allow components to share implicit state via context.
```jsx
function Tabs({ children }) { /* provides selected index */ }
Tabs.List = () => {/* render list of tabs */};
Tabs.Panel = () => {/* render panel based on selected */};
// Usage
<Tabs>
  <Tabs.List>...</Tabs.List>
  <Tabs.Panel>...</Tabs.Panel>
</Tabs>
```

### Render Props
Share logic via a function prop.
```jsx
function Mouse({ children }) {
  const [pos, setPos] = useState({x:0,y:0});
  useEffect(() => { /* track mouse */ }, []);
  return children(pos);
}
// Usage
<Mouse>{({x,y}) => <p>{x}, {y}</p>}</Mouse>
```

### Higher-Order Components (HOC)
Functions that take a component and return an enhanced one.
```jsx
function withAuth(Component) {
  return function Authenticated(props) { return isLoggedIn() ? <Component {...props}/> : <Login/>; }
}
```

### Custom Hooks
Reuse stateful logic.
```ts
function useFetch(url: string) {
  const [data, setData] = useState(null);
  useEffect(() => { fetch(url).then(r=>r.json()).then(setData) }, [url]);
  return data;
}
```

### Context Provider Pattern
Provide global state via React Context.
```jsx
function ThemeProvider({children}) {
  const theme = useThemeSettings();
  return <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>;
}
```

---

## Structural & Behavioral Patterns

### Observer (Pub/Sub)
React’s event system and custom event emitters follow Observer.
```ts
class EventEmitter { subscribe(fn){/*...*/} emit(data){/*...*/} }
```

### Singleton
Ensures a single instance (e.g., theme manager, modal service).
```ts
class ModalService { private static instance: ModalService; private constructor(){} }
```

### Factory
Create UI components dynamically.
```ts
function createButton(type: string) {
  switch(type) { case 'primary': return <PrimaryButton/>; /*...*/ }
}
```

### Strategy
Switch rendering or behavior based on props.
```jsx
const layouts = { grid: GridLayout, list: ListLayout };
function Content({ mode }) {
  const Layout = layouts[mode];
  return <Layout />;
}
```

---

## Component Composition Patterns

### Atomic Design
- **Atoms**: Buttons, Inputs
- **Molecules**: Form Groups
- **Organisms**: Header, Footer

### Controlled vs Uncontrolled
Discussed in previous sections; controlled for React-managed state, uncontrolled for refs.

---

## UI Architectural Patterns

### MVC / MVVM
- **MVC**: Model (data), View (UI), Controller (event handling)
- **MVVM**: ViewModel binds Model & View; React Hooks serve as ViewModel.

---

## Best Practices
- Combine SOLID with component patterns for maintainable code.
- Prefer composition over inheritance.
- Keep components small and focused.
- Use context sparingly; avoid over-nesting.

---

## Conclusion
Applying SOLID principles and UI-specific design patterns leads to scalable, maintainable, and performant interfaces. Understanding these concepts is key for advanced UI development.


## 29. What Are Prototypes?
In JavaScript, every object has an internal link to another object called its **prototype**.  
- The prototype provides inheritance: properties and methods on the prototype are accessible on the object instance.  
- Functions have a `prototype` property used when creating objects via `new`.

```js
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  console.log('Hello, ' + this.name);
};
const alice = new Person('Alice');
alice.greet(); // "Hello, Alice"
```

---

## 30. `__proto__` vs. `prototype`
- **`prototype`**  
  - A property on **constructor functions** (`Function` instances).  
  - Defines the object that instances will inherit from.  
  - Only functions have `prototype`.

- **`__proto__`**  
  - An internal reference on **every object** (exposed in many environments).  
  - Points to the object’s prototype.  
  - Used to look up inherited properties.

```js
function Foo() {}
console.log(typeof Foo.prototype);           // "object"
const obj = new Foo();
console.log(obj.__proto__ === Foo.prototype); // true
```

| Aspect                 | `prototype`                | `__proto__`                      |
|------------------------|----------------------------|----------------------------------|
| Belongs to             | Function objects           | All objects                      |
| Usage                  | Defines inheritance chain  | References actual prototype link |
| Standard               | ECMAScript                | Deprecated alias; better use `Object.getPrototypeOf` |

---

## 31. CSS Units: `rem`, `em`, `%`, and Others
- **`px`**: Absolute pixel units.  
- **`%`**: Relative to parent element’s corresponding property (e.g., width).  
- **`em`**: Relative to the **font-size** of the **current element**.  
- **`rem`**: Relative to the **root** (`<html>`) element’s font-size.  
- **`vh` / `vw`**: 1% of viewport height/width.  
- **`vmin` / `vmax`**: 1% of the smaller/larger of viewport dimensions.  
- **`ch`**: Width of the “0” (zero) glyph in the element’s font.  
- **`ex`**: Height of the “x” glyph in the element’s font.

```css
html { font-size: 16px; }
.container { width: 50%; /* half of parent */ }
.text { font-size: 2em; /* 2× parent font-size */ }
.heading { font-size: 2rem; /* 2× 16px = 32px */ }
.box { width: 50vw; /* 50% of viewport width */ }
```

---

## 32. `DOMContentLoaded` vs `load` Event
- **`DOMContentLoaded`**  
  - Fires when the HTML is fully parsed and the DOM tree is built.  
  - Does **not** wait for stylesheets, images, or subframes to finish loading.

- **`load`**  
  - Fires when the entire page is fully loaded, including all dependent resources (images, stylesheets, iframes).

```js
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM is ready');
});

window.addEventListener('load', () => {
  console.log('All resources finished loading');
});
```

---

## 33. `event.target` vs `event.currentTarget`
- **`event.target`**  
  - The actual element that initiated the event (could be a child).

- **`event.currentTarget`**  
  - The element on which the event listener is registered (the “listening” element).

```html
<ul id="list">
  <li id="item">Item</li>
</ul>
<script>
  const list = document.getElementById('list');
  list.addEventListener('click', (event) => {
    console.log(event.target.id);         // e.g., "item"
    console.log(event.currentTarget.id);  // "list"
  });
</script>
```
